//--- 010 Editor v9.02 Binary Template
//
//      File: RE_Engine_motlist.bt
//   Authors: alphaZomega, Che, Jackal
//   Version: 0.79
//   Purpose: Parse RE Engine motlist files
//  Category: RE Engine
// File Mask: *.motlist.*
//  ID Bytes: [+4] 6D 6C 73 74
//   History: July 2, 2023
//------------------------------------------------
LittleEndian();

//Set this to TRUE to make the template skip decompressing all the frame data:
local int SKIP_UNPACK <hidden=true> = FALSE;
local int SKIPALL <hidden=true> = FALSE;
local int NOCLIP <hidden=true> = 0;

local int64 i <hidden=true> = 0, numOffs <hidden=true> = 0, isEndOfClip <hidden=true> = FALSE,
            j <hidden=true> = 0, pos <hidden=true>, Type <hidden=true>,
            start <hidden=true>, k <hidden=true> = 0, fnData <hidden=true>,
            frame <hidden=true>, pos2 <hidden=true>, pos3 <hidden=true>,
            motCounter <hidden=true> = 0, boneHeadersIdx <hidden=true> = 0, version <hidden=true>;
local char  bytes[8] <hidden=true>;
local byte  bIsMotFile <hidden=true>;
local int runningTotal <hidden=true>;
local int propSize <hidden=true> = 112;
local int keySize <hidden=true> = 40;
local int hasMTRE <hidden=true> = FindFirst("mtre",1,0,0,0.0,1,0,0,24);
local int matchSize <hidden=true>;

/* ----DEFINITIONS---- */
#define TRANSLATION (1)
#define ROTATION (1 << 1)
#define SCALE (1 << 2)

uint getMotSize(uint offset) {
	local uint posStart = FTell();
	local uint posEnd = offset;
	FSeek(offset);
    while (FTell()+4 < FileSize()) {
        if (ReadUInt(FTell()) == 544501613 || FTell() == HEADER.colOffs || FTell() == FileSize()) {
			if (ReadUInt(FTell()) == 544501613)
            	FSkip(-4);
			break;
        }
        FSkip(1);
    }
	posEnd = FTell();
	FSeek(posStart);
	return posEnd;
}

uint findNextMot(uint start) {
    local uint nextMotSt = FindFirst("mot ",1,0,0,0.0,1,start,0,24); //findNextOfInt(544501613);
    local uint nextMtreSt;
    if (hasMTRE != -1) {
        nextMtreSt = FindFirst("mtre",1,0,0,0.0,1,start,0,24);
        if (nextMtreSt != -1 && nextMotSt < nextMotSt)
            nextMotSt = nextMtreSt;
    }
    if (nextMotSt == -1)
        nextMotSt = FileSize();
    else nextMotSt -= 4;
    if (nextMotSt > HEADER.colOffs && HEADER.colOffs > start)
        nextMotSt = HEADER.colOffs;
    return nextMotSt;
}

int findNextOfInt(int toFind) {
    pos3 = FTell();
    while (FTell()+4 < FileSize() && FTell() != HEADER.colOffs) {
        if (ReadUInt(FTell()) == toFind) {
            FSkip(-4); break;
        }
        FSkip(1);
    }
    local int finalPos = FTell();
    if (FTell()==FileSize()-4)
        finalPos = FileSize();

    FSeek(pos3);
    return finalPos;
}

string Lower(string s) {
    local string s2 = s;
    for (k=0; k < sizeof(s); k++)
        s2[k] = ToLower(s[k]);
    return s2;
}

void align(int n) {
    if (FTell()%n == 0) return;
    FSkip(n - FTell()%n);
}

void skipToNextLine() {
    while (FTell() % 16 != 0) FSkip(1);
}

uint isHighestOffset(uint64 offset) {
    for (j=0; j<HEADER.numOffs; j++) {
        if (HEADER.Pointers[j] > offset)
            return 0;
    }
    return 1;
}

uint isBeforeColOffs(uint64 offset) {
    for (j=0; j<HEADER.numOffs; j++) {
        if (HEADER.Pointers[j] > offset && HEADER.Pointers[j] < HEADER.colOffs)
            return 0;
    }
    return 1;
}

int detectedFloat(uint64 offset) {
    if (offset+4 <= FileSize()) {
        local float flt = ReadFloat(offset);
        return (ReadUByte(offset+3) != 255 && flt != 0 && (Abs(flt) > 0.000001 && Abs(flt) < 10000000) );
    } return false;
}

int findS(string str, string term) { return (RegExSearch(str, term, matchSize, 0)); }

typedef byte BLANK <name=readBLANK, read=readBLANK>;

    string readBLANK(BLANK &ref) { return " ";}

//generic string reader
typedef struct(int64 atAddress, int64 addOffset, ubyte isAbsolute, ubyte isUTF8, ubyte isUint32)
{
    if (!isAbsolute) {
        if (atAddress > -1)
            FSeek(atAddress);
        if (isUint32)
            uint32 strOffset;
        else
            uint64 strOffset;
        FSeek(strOffset + addOffset);
    } else
        FSeek(atAddress + addOffset);

    if (!exists(strOffset) || strOffset > 0)
        if (isUTF8)
            string String;
        else
            wstring String;

    if (exists(strOffset)) {
        if (atAddress == -1 || startof(this) == atAddress)
            FSeek(startof(strOffset) + 8 - isUint32 * 4);
        else
            FSeek(startof(this)+1);
    }

} StringRead <read=ReadStringRead, write=WriteStringRead>;

    wstring ReadStringRead(StringRead &st) {
        if (exists(st.String))
            return st.String;
        local string s;
        if (exists(st.strOffset))
            SPrintf(s, "%i", st.strOffset);
        return s;
    }

    void WriteStringRead(StringRead &st, string s) {
        if (exists(st.String))
            st.String = s;
        else if (exists(st.strOffset))
            st.strOffset = Atoi(s);
    }

typedef struct {
    uchar uuid[16];
} rGUID <read=ReadrGUID>;

    string ReadrGUID (rGUID &g) {
        local char s[37];
        SPrintf(s,
            "%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x",
            g.uuid[0], g.uuid[1], g.uuid[2], g.uuid[3], g.uuid[4], g.uuid[5], g.uuid[6], g.uuid[7],
            g.uuid[8], g.uuid[9], g.uuid[10], g.uuid[11], g.uuid[12], g.uuid[13], g.uuid[14], g.uuid[15]
        );
        return s;
    }

typedef uint8 trckFlg_t<read=ReadTrckFlg, write=WriteTrckFlg>;
    string ReadTrckFlg(trckFlg_t f){
        string s;
        SPrintf(s, "%c %c %c",
                 (f & TRANSLATION) ? 84 : 32,
                 ( (f & ROTATION) >> 1 ) ? 82 : 32,
                 ( (f & SCALE) >> 2 ) ? 83 : 32
                );
        return s;
    }

typedef struct KEY {
    float frame <write=WriteCLIPKEYFrame>;
    float rate;
    enum {
        InterpolationType_Unknown = 0x0,
        InterpolationType_Discrete = 0x1,
        InterpolationType_Linear = 0x2,
        InterpolationType_Event = 0x3,
        InterpolationType_Slerp = 0x4,
        InterpolationType_Hermite = 0x5,
        InterpolationType_AutoHermite = 0x6,
        InterpolationType_Bezier = 0x7,
        InterpolationType_AutoBezier = 0x8,
        InterpolationType_OffsetFrame = 0x9,
        InterpolationType_OffsetSec = 0xA,
        InterpolationType_PassEvent = 0xB,
        InterpolationType_Bezier3D = 0xC,
        InterpolationType_Range = 0xD,
        InterpolationType_DiscreteToEnd = 0xE,
    } interpolationType : 8;
    uint32 instanceValue : 1;
    uint32 reserved : 23 <hidden=true>;
    uint32 reserved2 <hidden=true>;

    if (exists(parentof(this).PropInfo.DataType)) {
        switch (parentof(this).PropInfo.DataType) {

            //PropertyType_Unknown:
            case PropertyType_Bool:
            case PropertyType_S8:
                byte value : 1; break;
            case PropertyType_U8:
                ubyte value : 1; break;
            case PropertyType_S16:
                int16 value; break;
            case PropertyType_U16:
                uint16 value; break;
            case PropertyType_S32:
                int32 value; break;
            case PropertyType_U32:
                uint32 value; break;
            case PropertyType_S64:
                int64 value; break;
            case PropertyType_U64:
                uint64 value; break;
            case PropertyType_F32:
                double value; break;
            case PropertyType_F64:
                double value; break;
            case PropertyType_Str8:
            case PropertyType_Enum:
                uint64 value;
                FSeek(clipHeader.hermiteDataOffset + start + value);
                string String;
                break;
            case PropertyType_Guid:
            case PropertyType_Str16:
            case PropertyType_Asset:
                typedef struct {
                    uint64 value;
                    if (value > lastUnicodeNameOffs)
                        lastUnicodeNameOffs = value;
                    local uint motStart <hidden=true> = start;
                    local uint clipStart <hidden=true> = startof(clipHeader);
                    FSeek(clipHeader.unicodeNamesOffs + motStart + value*2);
                    wstring String;
                    FSeek(startof(value)+8);
                } CLIPString <read=ReadCLIPString, write=WriteCLIPString>;
                CLIPString String <write=WriteCLIPString>;
                break;
            default:
                int64 value;
                break;
        }
    } else {
        int64 value;
        FSkip(-8);
        double value;
    }
    FSeek(startof(this)+24);
    uint64 hermiteKeyIndex;
    FSeek(startof(this)+keySize);
};

typedef KEY clipKey <name=ReadKeyName, read=ReadClipKey, write=WriteClipKey>;

    string ReadKeyName (clipKey &k) { string s; SPrintf(s, "Key@%g ", k.frame); return s; }

    string ReadCLIPString (CLIPString &c) {
        return ReadWString(startof(c.String));
    }

    void WriteCLIPKEYFrame(float &f, string s) {
        f = Atof(s);
        if (exists(parentof(parentof(f)).PropInfo)) {
            local ushort ct;
            local float min = 99999.0, max = -99999.0;
            while(exists(parentof(parentof(f)).Keys[ct])) {
                if (parentof(parentof(f)).Keys[ct].frame < min)
                    min = parentof(parentof(f)).Keys[ct].frame;
                if (parentof(parentof(f)).Keys[ct].frame > max)
                    max = parentof(parentof(f)).Keys[ct].frame;
                ct++;
            }
            if (min < parentof(parentof(f)).PropInfo.ValueA || parentof(parentof(f)).PropInfo.ValueA == -1.0)
                parentof(parentof(f)).PropInfo.ValueA = min;
            if (max > parentof(parentof(f)).PropInfo.ValueB)
                parentof(parentof(f)).PropInfo.ValueB = max;
            CheckPROPERTYParentFrames(parentof(parentof(f)));
        }
    }

    void WriteCLIPString(CLIPString &c, string s) {
        local uint maxLen, pos = startof(c.String);
        while (ReadUShort(pos) != 0) pos += 2;
        while (ReadUShort(pos) == 0) pos += 2;
        maxLen = (pos - 2 - startof(c.String)) / 2 + 1;
        OverwriteBytes(startof(c.String), maxLen*2, 0);
        if (sizeof(s) > maxLen) {
            if (exists(END_CLIP) && startof(c.String) < startof(END_CLIP)) {
                MessageBox( idOk, "Insert Data", "END CLIP data detected!\nYou must mot-swap your mot after END_CLIP data to insert bytes");
                return;
            }
            local ushort M, C, P, K, diff = (sizeof(s)-maxLen)*2;
            while(exists(MOT[M]) && startof(MOT[M]) != c.motStart) M++;
            local uint motSize = MOT[M].clipEnd - startof(MOT[M]);
            while(exists(MOT[M].CLIP.Clip[C]) && startof(MOT[M].CLIP.Clip[C]) != c.clipStart) C++;
            while(exists(MOT[M].CLIP.Clip[C].Properties.Property[P])) {
                if (MOT[M].CLIP.Clip[C].Properties.Property[P].PropInfo.nameOffset > c.value)
                    MOT[M].CLIP.Clip[C].Properties.Property[P].PropInfo.nameOffset += (diff / 2);
                if (MOT[M].CLIP.Clip[C].Properties.Property[P].PropInfo.DataType == 13) {
                    K=0;
                    while(exists(MOT[M].CLIP.Clip[C].Properties.Property[P].Keys[K])) {
                        if (exists(MOT[M].CLIP.Clip[C].Properties.Property[P].Keys[K].String) && MOT[M].CLIP.Clip[C].Properties.Property[P].Keys[K].String.value > c.value)
                            MOT[M].CLIP.Clip[C].Properties.Property[P].Keys[K].String.value += (diff / 2);
                        K++;
                    }
                }
                P++;
            }
            local uint oldDataSz;
            if (exists(MOT[M].CLIP.dataHeader))
                oldDataSz = MOT[M].CLIP.dataHeader.dataSize;
            local uint padBytes, nextMotSt = findNextMot(startof(c.String));

            while(nextMotSt != FileSize() && (nextMotSt+diff+padBytes) % 16 != 0)
                padBytes++;
            FixOffsets(c.motStart, c.motStart + motSize, startof(c.String)-c.motStart, c.motStart + motSize, diff, false);
            FixOffsets(0, sizeof(HEADER), startof(c.String), FileSize()+diff+padBytes, diff+padBytes, false);
            if (padBytes)
                InsertBytes(nextMotSt, padBytes, 0);
            if (oldDataSz)
                MOT[M].CLIP.dataHeader.dataSize = oldDataSz;
            InsertBytes(startof(c.String), diff, 0);
            WriteWString(startof(c.String), s);
            MessageBox( idOk, "Insert Data", "Press F5 to refresh the template and fix template results");
        } else
            WriteWString(startof(c.String), s);
    }

    string ReadClipKey (clipKey &k) {
        local string s, t;
        if (exists(k.String)) {
            if (exists(k.String.String))
                s += (wstring)ReadCLIPString(k.String);
            else s += k.String;
        } else if (detectedFloat(startof(k.value)) || detectedFloat(startof(k.value)+4) && ReadUInt64(startof(k.value)) != 0)
            SPrintf(s, "%lf", ReadDouble(startof(k.value)));
        else
            SPrintf(s, "%i", ReadInt(startof(k.value)));
        if (exists(k.interpolationHermiteValue))
            SPrintf(s, "%s  (%lf)", s, k.interpolationHermiteValue);
        SPrintf(s, "%s  @%g", s, k.frame);
        return s;
    }

    void WriteClipKey(clipKey &k, string in) {
        local string s;
        local int findIdx = findS(in, "  @");
        if (findIdx != -1) {
            s = SubStr(in, 0, findIdx);
            WriteCLIPKEYFrame(k.frame, SubStr(in, findIdx+3, -1));
        } else if (findS(in, " ") != -1){
            s = SubStr(in, 0, findS(in, " "));
        } else
            s = in;
        if (exists(k.String.String)) {
            WriteCLIPString(k.String, s);
        } else if (exists(k.String) && sizeof(s) <= sizeof(k.String))
            k.String = s;
        else if (exists(parentof(k).PropInfo.DataType) && parentof(k).PropInfo.DataType == PropertyType_F32)
            WriteDouble(startof(k.value), Atof(s));
        else
            WriteInt64(startof(k.value), Atoi(s));
    }

enum <ubyte> PropertyType
{
  PropertyType_Unknown = 0x0,
  PropertyType_Bool = 0x1,
  PropertyType_S8 = 0x2,
  PropertyType_U8 = 0x3,
  PropertyType_S16 = 0x4,
  PropertyType_U16 = 0x5,
  PropertyType_S32 = 0x6,
  PropertyType_U32 = 0x7,
  PropertyType_S64 = 0x8,
  PropertyType_U64 = 0x9,
  PropertyType_F32 = 0xA,
  PropertyType_F64 = 0xB,
  PropertyType_Str8 = 0xC,
  PropertyType_Str16 = 0xD,
  PropertyType_Enum = 0xE,
  PropertyType_Quaternion = 0xF,
  PropertyType_Array = 0x10,
  PropertyType_NativeArray = 0x11,
  PropertyType_Class = 0x12,
  PropertyType_NativeClass = 0x13,
  PropertyType_Struct = 0x14,
  PropertyType_Vec2 = 0x15,
  PropertyType_Vec3 = 0x16,
  PropertyType_Vec4 = 0x17,
  PropertyType_Color = 0x18,
  PropertyType_Range = 0x19,
  PropertyType_Float2 = 0x1A,
  PropertyType_Float3 = 0x1B,
  PropertyType_Float4 = 0x1C,
  PropertyType_RangeI = 0x1D,
  PropertyType_Point = 0x1E,
  PropertyType_Size = 0x1F,
  PropertyType_Asset = 0x20,
  PropertyType_Action = 0x21,
  PropertyType_Guid = 0x22,
  PropertyType_Uint2 = 0x23,
  PropertyType_Uint3 = 0x24,
  PropertyType_Uint4 = 0x25,
  PropertyType_Int2 = 0x26,
  PropertyType_Int3 = 0x27,
  PropertyType_Int4 = 0x28,
  PropertyType_OBB = 0x29,
  PropertyType_Mat4 = 0x2A,
  PropertyType_Rect = 0x2B,
  PropertyType_PathPoint3D = 0x2C,
  PropertyType_Plane = 0x2D,
  PropertyType_Sphere = 0x2E,
  PropertyType_Capsule = 0x2F,
  PropertyType_AABB = 0x30,
  PropertyType_Nullable = 0x31,
  PropertyType_Sfix = 0x32,
  PropertyType_Sfix2 = 0x33,
  PropertyType_Sfix3 = 0x34,
  PropertyType_Sfix4 = 0x35,
  PropertyType_AnimationCurve = 0x36,
  PropertyType_KeyFrame = 0x37,
  PropertyType_GameObjectRef = 0x38,
};

typedef struct {
    struct PROPINFO {
        if (HEADER.version==60) {
            PropertyType DataType;
            FSkip(3);
        }
        if (HEADER.version < 486)
            uint32 uknValue;
        float ValueA <name="Value A (Start)", write=WritePROPERTYFrame>;
        float ValueB <name="Value B (End)", write=WritePROPERTYFrame>;
        if (HEADER.version==60) {
            uint32 U32_1;
            uint32 U32_2;
        } else
            uint64 U64_1;

        if (HEADER.version >= 486) { //RE8
                uint64 nameOffset;
                uint64 dataOffset;
                uint64 ChildStartIndex;
                ushort ChildMembershipCount;
                short arrayIndex;
                if (HEADER.Version > 524)
                    ubyte speedPointNum;
                else
                    short speedPointNum;
                PropertyType DataType;
                if (HEADER.Version > 524)
                    ubyte uknByte00;
                ubyte uknByte : 4;
                ubyte clipType : 2;
                ubyte uknByte : 2;
                uint64 lastKeyOffset;
                if (HEADER.version < 751) {
                    uint64 speedPointOffset;
                    uint64 clipPropertyOffset;
                }
        } else {
            if (HEADER.version == 60) {
                FSkip(24);
            } else {
                PropertyType DataType;
                ubyte uknCount <hidden=true>;
                FSkip(2);
                if (HEADER.version == 99){
                    uint32 hash1;
                    uint32 hash2;
                }else FSkip(8);
            }
            uint64 nameOffset, nameOffset;

            if (HEADER.version == 60) {
                uint64 uknRE7;
                FSkip(8);
            }
            FSkip(8);
            if (HEADER.version != 60)
                FSkip(16);

            uint64 ChildStartIndex, ChildMembershipCount;
            if (HEADER.version == 60) {
                FSkip(8);
                uint64 uknRE7;
            }
        }
        FSeek(clipHeader.namesOffs + start + PropInfo.nameOffset[0]);
        string FunctionName  <hidden=false>;
        if (HEADER.version < 486 && PropInfo.nameOffset[1] > 0) {
            FSeek(clipHeader.unicodeNamesOffs + start + PropInfo.nameOffset[1]*2);
            wstring wFunctionName <hidden=false>;
        }
        FSeek(startof(this)+propSize);
    } PropInfo <read=ReadPROPINFO, name="[PropInfo]">;

    switch (PropInfo.DataType) {
        case PropertyType_NativeArray:
        case PropertyType_Nullable:
        case PropertyType_NativeClass:
        case PropertyType_Range:
        case PropertyType_RangeI:
        case PropertyType_Vec4:
        case PropertyType_Vec3:
        case PropertyType_Vec2:
        case PropertyType_Float4:
        case PropertyType_Quaternion:
        case PropertyType_OBB:
        case PropertyType_Mat4:
        case PropertyType_Class:
        case PropertyType_Array:
        case PropertyType_Struct:
        case PropertyType_Color:
        case PropertyType_Float2:
        case PropertyType_Float3:
        case PropertyType_Point:
            FSeek(clipHeader.propertiesOffs + start + (propSize*PropInfo.ChildStartIndex));
            if (PropInfo.ChildMembershipCount)
                struct PROPERTY ChildProp[PropInfo.ChildMembershipCount] <optimize=false>;
            break;
        default:
            if (PropInfo.ChildMembershipCount) {
                Type = PropInfo.DataType;
                if (exists(PropInfo.clipType) && PropInfo.clipType == 3) {
                    FSeek(clipHeader.shortValueKeyOffs + start + (16*PropInfo.ChildStartIndex));
                    for (j=0; j<PropInfo.ChildMembershipCount; j++)
                        if (FTell()+28 <= FileSize())
                            struct shortValueKey Keys;
                } else if (exists(PropInfo.clipType) && PropInfo.clipType == 1) {
                    FSeek(clipHeader.shortKeyOffs + start + (8*PropInfo.ChildStartIndex));
                    for (j=0; j<PropInfo.ChildMembershipCount; j++)
                        if (FTell()+28 <= FileSize())
                            struct shortKey Keys;
                } else {
                    FSeek(clipHeader.keysOffs + start + (keySize*PropInfo.ChildStartIndex));
                    for (j=0; j<PropInfo.ChildMembershipCount; j++)
                        if (FTell()+28 <= FileSize())
                            struct clipKey Keys;
                }
            }
            break;
    }

    FSeek(startof(this)+propSize);
} PROPERTY <name=ReadPROPERTYNAME, read=ReadPROPERTY, write=WritePROPERTY>;

    string ReadPROPERTY (PROPERTY &input) {
        string s = "";
        SPrintf(s, "[%g, %g]", input.PropInfo.ValueA, input.PropInfo.ValueB );
        return s;
    }

    string ReadPROPERTYNAME (PROPERTY &input) {
        local string fnName;
        if (exists(input.PropInfo.FunctionName)) {
            fnName = input.PropInfo.FunctionName;
            if (exists(input.PropInfo.wFunctionName))
                fnName = input.PropInfo.wFunctionName;
            if (exists(input.ChildProp)) {
                local string s;
                SPrintf(s, "*[%ix] %s", input.PropInfo.ChildMembershipCount, fnName );
                return s;
            } else if (exists(input.Keys))
                return  "*" + fnName;
            else
                return fnName;
        }
        return "";
    }

    void WritePROPERTYFrame(float &f, string s) {
        f = Atof(s);
        CheckPROPERTYParentFrames(parentof(f));
    }

    void CheckPROPERTYParentFrames(PROPERTY &f) {
        if (exists(parentof(f).PropInfo)) {
            if (f.PropInfo.ValueA < parentof(f).PropInfo.ValueA || parentof(f).PropInfo.ValueA == -1.0)
                parentof(f).PropInfo.ValueA = f.PropInfo.ValueA;
            if (f.PropInfo.ValueB > parentof(f).PropInfo.ValueB)
                parentof(f).PropInfo.ValueB = f.PropInfo.ValueB;
            CheckPROPERTYParentFrames(parentof(f));
        }
    }

    void WritePROPERTY (PROPERTY &f, string s ) {
        local string old = ReadPROPERTY(f);
        if (old[0]==0x5B)
            SScanf(s, "[%g, %g]", f.PropInfo.ValueA, f.PropInfo.ValueB);
        else
            SScanf(s, "%g %g", f.PropInfo.ValueA, f.PropInfo.ValueB);
        CheckPROPERTYParentFrames(f);
    }

    string ReadPROPINFO(PROPINFO &p) { return EnumToString(p.DataType); }

typedef struct {
    if (HEADER.version < 486) {
        uint32 nodeCount, propCount;
        float Start_Frame, End_Frame;
        struct rGUID GUIDs[2];
        FSkip(8);
    } else {
        ushort nodeCount;
        ushort propCount;
        uint nodeType : 8;
        uint padding : 24 <hidden=true>;
    }
    uint64 hash;
    uint64 nameOffset, nameOffset, firstPropIdx;
    if (HEADER.version == 85)
        uint64 firstPropIdx;
    pos = FTell();
    if (HEADER.version == 99) {
        FSeek(clipHeader.unicodeNamesOffs + start + nameOffset[0] * 2);
        wstring name;
    } else if (HEADER.version >= 486) {
        FSeek(clipHeader.unicodeNamesOffs + start + nameOffset[0] * 2);
        wstring name;
    } else {
        FSeek(clipHeader.namesOffs + start + nameOffset[0]);
        string name;
    }
    FSeek(pos);
} CTRACKS <read=ReadCTRACKS>;
    string ReadCTRACKS (CTRACKS &input) { return input.name; }


typedef struct {

    if (HEADER.Version >= 653) {
        propSize = 56;
        keySize = 32;
    } else if (HEADER.version == 486 || HEADER.version == 484) {
        propSize = 72;
        keySize = 32;
    } else if (HEADER.version==60) {
        propSize = 120;
    } else if (HEADER.version==99) {
        keySize = 32;
    }

    if (isEndOfClip) {
        uint64 endClipOffs;
        if (endClipOffs)
            FSeek(endClipOffs);
    }

    struct {

        FSkip(8);
        uint64 ClipOffset;
        uint64 endClipStructsRelocation;
        FSkip(4);
        uint32 uknIntA;
        uint32 uknIntB;
        uint uknData[7];

        uint32 Magic;
        uint32 version;
        float NumFrames;
        uint32 numNodes, numProperties;
        uint32 numKeys;
        if (version >= 85) {
            uint32 shortKeys;
            uint32 uknKeysCount1;
            uint32 shortValueKeys;
            uint32 uknKeysCount2;
        }

        if (HEADER.version != 99 && HEADER.version < 486)
            rGUID Guid;

        uint64 clipDataOffs, propertiesOffs;
        uint64 keysOffs;
        if (version >= 85) {
            uint64 shortKeyOffs;
            uint64 keyOffs4;
            uint64 shortValueKeyOffs;
        }
        uint64 uknOffset1;
        uint64 hermiteDataOffset;

        if (HEADER.version == 60)
            uint64 namesOffsExtra[3];
        else if (HEADER.Version == 663 || HEADER.Version==653)
            uint64 namesOffsExtra[1];
        else if (version >= 85)
            uint64 namesOffsExtra[2];
        else if (HEADER.Version == 85)
            uint64 namesOffsExtra[3];
        else
            uint64 namesOffsExtra[2];

        uint64 namesOffs;
        uint64 unicodeNamesOffs;
        uint64 endClipStructsOffs;
        // if (HEADER.version < 653)
            uint64 endClipStructsOffs2;

    } clipHeader <name="Header">;

    local uint lastUnicodeNameOffs <hidden=true>;

    FSeek(clipHeader.clipDataOffs + start);
    if (clipHeader.numNodes > 0) {
        struct {
            CTRACKS cTrack[clipHeader.numNodes] <optimize=false>;
        } cTracks <name="Tracks">;
    }

    FSeek(clipHeader.propertiesOffs + start);
    if (clipHeader.numProperties > 0) {
        struct {
            struct PROPERTY Property[clipHeader.numProperties] <optimize=false>;
        } Properties;
    }

    if (clipHeader.numKeys > 0) {
        FSeek(clipHeader.keysOffs + start);
        struct clipKey Keys[clipHeader.numKeys] <optimize=true>;
    }
    if (exists(clipHeader.shortKeys) && clipHeader.shortKeys) {
        FSeek(clipHeader.shortKeyOffs + start);
        struct shortKey { float frame; ubyte interpolation; ubyte flags; uint16 nulls; } ShortKeys[clipHeader.shortKeys];
    }
    if (exists(clipHeader.shortValueKeys) && clipHeader.shortValueKeys) {
        FSeek(clipHeader.shortValueKeyOffs + start);
        struct shortValueKey {
            float frame;
            ubyte interpolation; ubyte flags; uint16 nulls;
            uint64 valueOrOffset;
        } shortValueKeys[clipHeader.shortValueKeys] <read=Str("%f %d", frame, valueOrOffset)>;
    }

    if (clipHeader.hermiteDataOffset < clipHeader.namesOffsExtra[0]) {
        FSeek(clipHeader.hermiteDataOffset+start);
        struct  {
            float x1, y1;
            float x2, y2;
        } Hermite_Data[(clipHeader.namesOffsExtra[0] - clipHeader.hermiteDataOffset) / 16] <read=Str("%f,%f %f,%f", x1, y1, x2, y2)>;
    }

    if (clipHeader.namesOffs > clipHeader.namesOffsExtra[0]) {
        uint32 UnknownData[(clipHeader.namesOffs - clipHeader.namesOffsExtra[0]) / 4];
    }

    FSeek(clipHeader.namesOffs + start);
    struct {
        for (k = 0; k < clipHeader.numProperties + clipHeader.numNodes; k++) {
            if (ReadByte() == 0)
                break;
            struct StringRead Name(FTell(), 0, 1, 1, 0);
        }
    } Names;


    FSeek(clipHeader.unicodeNamesOffs + start);
    struct {
        ubyte stringExpander <read=ReadStringExpander, write=WriteStringExpander>;
        FSkip(-1);
        while(ReadShort())
            struct StringRead Name(FTell(), 0, 1, 0, 0);
    } NamesUnicode <name="Names (Unicode)">;

    if (clipHeader.endClipStructsOffs > 0 && clipHeader.version > 18) { // 18 == re7, I don't think this exists here
        FSeek(clipHeader.endClipStructsOffs + start);
        skipToNextLine();
        struct {
            int32 count1, count2;
            int64 offset1;
            int64 offset2;
            if (count1 > 0) {
                FSeek(offset1 + start);
                struct {
                    uint propertyUtf16Hash;
                    ushort flags, valueCount;
                    uint64 valueOffset;
                } PropsData1[count1];
                struct {
                    float frame;
                    uint value;
                } PropValues1[count1];
            }
            if (count2 > 0) {
                FSeek(offset2 + start);
                struct {
                    uint propertyUtf16Hash;
                    ushort flags, valueCount;
                    uint64 valueOffset;
                } PropsData2[count2];
                struct {
                    float frame;
                    uint value;
                } PropValues2[count2];
            }
        } ExtraPropertyData;
    }

    if (HEADER.version > 60 && clipHeader.numNodes > 1) {
        FSeek(clipHeader.endClipStructsRelocation + start);
        struct {
            struct {
                int32 ukn0;
                int32 ukn1;
                int32 ukn2;
                int32 ukn3;
                if (HEADER.version >= 486) {
                    int32 ukn4;
                    int32 ukn5;
                    int32 ukn6;
                }
            } endClipStruct[clipHeader.numNodes-1] <optimize=false, open=true>;
        } endClipStructs  <name="End Clip Structures">;
    }

    local int pos <hidden=true> = FTell();

    FSeek(clipHeader.propertiesOffs + start);
    if (clipHeader.numNodes && clipHeader.numProperties)
        struct {
            for (k=0; k<clipHeader.numNodes; k++) {
                if (cTracks.cTrack[k].propCount > 0) {
                    FSeek(clipHeader.propertiesOffs + start + (cTracks.cTrack[k].firstPropIdx * propSize));
                    struct PSTRUCT{
                        local int p <hidden=true>;
                        local string name<hidden=true>  = cTracks.cTrack[k].name;
                        for (p=0; p<cTracks.cTrack[k].propCount; p++)
                            PROPERTY Property <optimize=false>;
                    } cTrack <name=ReadPSTRUCTName, read=ReadPSTRUCT>;
                }
            }
        } Sorted_Data <name="Sorted Data (Edit Here)", open=true>;
        BLANK blank;
    FSeek(pos);
    //if (FTell()<startof(this)) FSeek(startof(this)+1);
} CLIP_ENTRY <fgcolor=cGreen, read=ReadCLIP_ENTRY>;

wstring ReadCLIP_ENTRY(CLIP_ENTRY &c) {
    if (exists(c.cTracks.cTrack[1].name))
        return c.cTracks.cTrack[1].name;
    return "";
}

string ReadStringExpander(ubyte &u) {
    return "[Input here to add 64 bytes of string padding]";
}

void WriteStringExpander(ubyte &u, string s) {
    if (exists(END_CLIP) && startof(u) < startof(END_CLIP)) {
        MessageBox( idOk, "Insert Data", "END CLIP data detected!\nYou must mot-swap your mot after END_CLIP data to insert bytes");
        return;
    }
    local uint motStart = startof(parentof(parentof(parentof(parentof(u)))));
    local uint clipStart = startof(parentof(parentof(u)));
    local ushort M, C;
    while(exists(MOT[M]) && startof(MOT[M]) != motStart) M++;
    local uint motSize = MOT[M].clipEnd - startof(MOT[M]);
    while(exists(MOT[M].CLIP.Clip[C]) && startof(MOT[M].CLIP.Clip[C]) != clipStart) C++;
    local uint tmp, insertPt = startof(u) + parentof(parentof(u)).lastUnicodeNameOffs*2;
    while(tmp!=2) {
        insertPt = insertPt + tmp;
        tmp = sizeof(ReadWString(insertPt));
    }
    FixOffsets(motStart, motStart+motSize, insertPt-motStart, motStart + motSize, 64, false);
    FixOffsets(0, sizeof(HEADER), insertPt, FileSize()+64, 64, false);
    InsertBytes(insertPt, 64, 0);
    MessageBox( idOk, "Insert Data", "Press F5 to refresh the template and fix template results");
}

typedef struct MotlistClip {
    uint64 clipOffset[MOT_HEADER.clipCount] <optimize=false>;
	FSeek(clipOffset[0] + start);

    if (NOCLIP == FALSE) {
        local int q <hidden=true>;
        for (q=0; q<MOT_HEADER.clipCount; q++) {
            FSeek(clipOffset[q] + start);
            CLIP_ENTRY Clip;
        }
	}

    //unknown CLIP data header stuff:
    if (exists(MOT_HEADER) && MOT_HEADER.motEndClipDataOffset != 0 && ReadUInt64(MOT_HEADER.motEndClipDataOffset + start) > 0 ) {
        FSeek(MOT_HEADER.motEndClipDataOffset + start);
        local int motClipDataCount = MOT_HEADER.motEndClipCount;
        local int remainingMotClip = motClipDataCount;
        uint64 firstMotEndClipOffset;
        FSeek(firstMotEndClipOffset + start);
        struct MotClipHeader {
            if (MOT_HEADER.version < 486) {
                uint64 valuesOffset;
            } else {
                if (remainingMotClip > 1) {
                    remainingMotClip = remainingMotClip - 1;
                    uint64 nextHeaderOffset;
                }
            }
            ubyte count1, type1, count2, count3;
            if (exists(valuesOffset)) {
                FSeek(valuesOffset + start);
            }
            if (count1 > 100) { // edge case hack
                FSkip(4);
                ubyte count1, type1, count2, count3;
            }
            if (type1 == 2 || type1 == 4) {
                float values1[count1 * type1];
            } else {
                float values1[count1 + type1];
            }
            if (count2 > 0 || count3 > 0) float values2[1]; // idk, these counts are weird
            align(8);
        } dataHeader[MOT_HEADER.motEndClipCount] <optimize=false>;

        if (exists(MOT_HEADER.motEndClipFrameValuesOffset)) {
            FSeek(MOT_HEADER.motEndClipFrameValuesOffset + start);
            uint64 floatPairsOffsets[motClipDataCount];
            struct {
                align(8);
                uint32 floatPairsCount;
                if (floatPairsCount > 0) {
                    struct {
                        float frame, value;
                    } FrameValues[floatPairsCount] <read=Str("%f %f", frame, value)>;
                }
            } FrameData[motClipDataCount] <optimize=false>;
        }
    }
};
    string ReadPSTRUCTName(PSTRUCT &input) { return input.name; }

    string ReadPSTRUCT(PSTRUCT &input) { if (exists(input.Property[0])) return ReadPROPERTYNAME(input.Property[0]); return ""; }

typedef struct keys (uint32 keyCount, uint32 flags, uint64 frameDataOffs) {
    switch (flags >> 20)
    {
        case 2:
            ubyte frameIndex[keyCount];
            break;

        case 4:
            int16 frameIndex[keyCount];
            break;

        case 5:
            int32 frameIndex[keyCount];
            break;

        default:
            break;
    }
};

typedef struct FrameData (uint32 keyCount, uint32 flags, uint64 frameDataOffs) {
    local uint keyFrameDataType <format=hex> = flags & 0xF00000;
    local uint keyFrameDataTypeOther <format=hex> = flags >> 20;
    local uint compression <format=hex> = flags & 0xFF000;

    local uint unkFlag <format=hex> = flags & 0xFFF;
};

typedef ulong LocFrameType_t<name="Translation Decompression", read=ReadLocFrameType, write=WriteLocFrameType>;
    string ReadLocFrameType(LocFrameType_t f){
    if (MOT[0].MOT_HEADER.version == 65 || MOT[0].MOT_HEADER.version == 43) {
        switch (f & 0xFF000)
        {   //RE2 and RE7
            case 0x00000: string s = "LoadVector3sFull"; break;
            case 0x20000: string s = "LoadVector3s5BitA"; break;
            case 0x30000: string s = "LoadVector3s10BitA"; break;
            case 0x40000: string s = "LoadVector3s10BitA"; break;
            case 0x70000: string s = "LoadVector3s21BitA"; break;
            case 0x31000: string s = "LoadVector3sXAxis"; break;
            case 0x32000: string s = "LoadVector3sYAxis"; break;
            case 0x33000: string s = "LoadVector3sZAxis"; break;
            case 0x21000: string s = "LoadVector3sXAxis16Bit"; break;
            case 0x22000: string s = "LoadVector3sYAxis16Bit"; break;
            case 0x23000: string s = "LoadVector3sZAxis16Bit"; break;
            case 0x24000: string s = "LoadVector3sXYZAxis16Bit"; break;
            default: string s = "Unknown Type"; break;
        }
    } else {
        switch (f & 0xFF000)
        {   //RE3
            case 0x00000: string s = "LoadVector3sFull"; break;
            case 0x20000: string s = "LoadVector3s5BitB"; break;
            case 0x25000: string s = "LoadVector3sXYAxis8Bit"; break;
            case 0x26000: string s = "LoadVector3sXZAxis8Bit"; break;
            case 0x27000: string s = "LoadVector3sXYAxis8Bit"; break;
            case 0x27000: string s = "LoadVector3s5BitB"; break; // TODO verify exists and correct - pragmata conflict
            case 0x30000: string s = "LoadVector3s5BitB"; break;
            case 0x40000: string s = "LoadVector3s10BitB"; break;
            case 0x50000: string s = "LoadVector3s5BitUnpadded"; break;
            case 0x60000: string s = "LoadVector3s24Bit"; break;
            case 0x80000: string s = "LoadVector3s21BitB"; break;
            case 0x87000: string s = "LoadVector3sUknNew"; break;
            case 0x21000: string s = "LoadVector3sXAxis16Bit"; break;
            case 0x22000: string s = "LoadVector3sYAxis16Bit"; break;
            case 0x23000: string s = "LoadVector3sZAxis16Bit"; break;
            case 0x24000: string s = "LoadVector3sXYZAxis16Bit"; break;
            case 0x31000: string s = "LoadVector3sXAxisB"; break;
            case 0x32000: string s = "LoadVector3sYAxisB"; break;
            case 0x33000: string s = "LoadVector3sZAxisB"; break;
            case 0x37000: string s = "LoadVector3s3ByteUknPragmata"; break;
            case 0x41000: string s = "LoadVector3sXAxis"; break;
            case 0x42000: string s = "LoadVector3sYAxis"; break;
            case 0x43000: string s = "LoadVector3sZAxis"; break;
            case 0x44000: string s = "LoadVector3sXYZAxis"; break;
            case 0x45000: string s = "LoadVector3sYZAxis16Bit"; break;
            case 0x46000: string s = "LoadVector3sXZAxis16Bit"; break;
            case 0x47000: string s = "LoadVector3sXYAxis16Bit"; break;
            case 0x55000: string s = "LoadVector3sXYAxis20Bit"; break;
            case 0x56000: string s = "LoadVector3sXZAxis20Bit"; break;
            case 0x57000: string s = "LoadVector3sZXAxis20Bit"; break;
            case 0x70000: string s = "LoadVector3s18Bit"; break;
            default: string s = "Unknown Type"; break;
        }
    }
        return s;
    }

typedef float VectorFull <read=VectorRead, write=VectorWrite>;
    string VectorRead( VectorFull f ) {
        string s;
        SPrintf( s, "%f", f );
        return s;
    }
    void VectorWrite( VectorFull &f, string s ) {
        local float ff = Atof(s);
        f = (VectorFull )( (float)(ff) );
    }

typedef ulong RotFrameType_t<name="Rotation Decompression", read=ReadRotFrameType, write=WriteRotFrameType>;
    string ReadRotFrameType(RotFrameType_t f){
    if (MOT[0].MOT_HEADER.version == 65 || MOT[0].MOT_HEADER.version == 43) {
        switch (f & 0xFF000)
        {   //RE2 and RE7
            case 0x00000: string s = "LoadQuaternionsFull"; break;
            case 0xB0000: string s = "LoadQuaternions3Component"; break;
            case 0xC0000: string s = "LoadQuaternions3Component"; break;
            case 0x30000: string s = "LoadQuaternions10Bit"; break;
            case 0x40000: string s = "LoadQuaternions10Bit"; break;
            case 0x50000: string s = "LoadQuaternions16Bit"; break;
            case 0x70000: string s = "LoadQuaternions21Bit"; break;
            case 0x21000: string s = "LoadQuaternionsXAxis16Bit"; break;
            case 0x22000: string s = "LoadQuaternionsYAxis16Bit"; break;
            case 0x23000: string s = "LoadQuaternionsZAxis16Bit"; break;
            case 0x31000: string s = "LoadQuaternionsXAxis"; break;
            case 0x41000: string s = "LoadQuaternionsXAxis"; break;
            case 0x32000: string s = "LoadQuaternionsYAxis"; break;
            case 0x42000: string s = "LoadQuaternionsYAxis"; break;
            case 0x33000: string s = "LoadQuaternionsZAxis"; break;
            case 0x43000: string s = "LoadQuaternionsZAxis"; break;
            default: string s = "Unknown Type"; break;
        }
    } else {
        switch (f & 0xFF000)
        {   //RE3
            case 0x00000: string s = "LoadQuaternionsFull"; break;
            case 0xB0000: string s = "LoadQuaternions3Component"; break;
            case 0xC0000: string s = "LoadQuaternions3Component"; break;
            case 0x20000: string s = "LoadQuaternions5Bit"; break;
            case 0x30000: string s = "LoadQuaternions8Bit"; break;
            case 0x40000: string s = "LoadQuaternions10Bit"; break;
            case 0x50000: string s = "LoadQuaternions13Bit"; break;
            case 0x60000: string s = "LoadQuaternions16Bit"; break;
            case 0x70000: string s = "LoadQuaternions18Bit"; break;
            case 0x80000: string s = "LoadQuaternions21Bit"; break;
            case 0x40000: string s = "LoadQuaternions10Bit"; break;
            case 0x21000: string s = "LoadQuaternionsXAxis16Bit"; break;
            case 0x22000: string s = "LoadQuaternionsYAxis16Bit"; break;
            case 0x23000: string s = "LoadQuaternionsZAxis16Bit"; break;
            case 0x31000: string s = "LoadQuaternionsXAxis"; break;
            case 0x41000: string s = "LoadQuaternionsXAxis"; break;
            case 0x32000: string s = "LoadQuaternionsYAxis"; break;
            case 0x42000: string s = "LoadQuaternionsYAxis"; break;
            case 0x33000: string s = "LoadQuaternionsZAxis"; break;
            case 0x43000: string s = "LoadQuaternionsZAxis"; break;
            default: string s = "Unknown Type"; break;
        }
    }
        return s;
    }

typedef ulong ScaleFrameType_t<name="Scale Decompression", read=ReadScaleFrameType, write=WriteScaleFrameType>;
    string ReadScaleFrameType(ScaleFrameType_t f){
    switch (f & 0xFF000)
    {
        case 0x00000: string s = "LoadVector3sFull"; break;
        case 0x20000: string s = "LoadVector3s5BitA"; break;
        case 0x30000: string s = "LoadVector3s10BitA"; break;
        case 0x34000: string s = "LoadScalesXYZ"; break;
        case 0x40000: string s = "LoadVector3s10BitA"; break;
        case 0x70000: string s = "LoadVector3s21BitA"; break;
        case 0x31000: string s = "LoadVector3sXAxis"; break;
        case 0x32000: string s = "LoadVector3sYAxis"; break;
        case 0x33000: string s = "LoadVector3sZAxis"; break;
        case 0x21000: string s = "LoadVector3sXAxis16Bit"; break;
        case 0x22000: string s = "LoadVector3sYAxis16Bit"; break;
        case 0x23000: string s = "LoadVector3sZAxis16Bit"; break;
        case 0x24000: string s = "LoadVector3sXYZAxis16Bit"; break; // Test
        default: string s = "Unknown Type"; break;
    }
        return s;
    }

typedef struct track {
    uint32 flags <format=binary>; //track compression among them
    uint32 keyCount;

    //if (MOT_HEADER.version == 78 || MOT_HEADER.version == 458 || MOT_HEADER.version == 456 || MOT_HEADER.version == 495) //40 bytes RE2, 20 bytes RE3
    if (MOT_HEADER.version >= 78)
    {
        uint32 frameIndOffs <format=hex>;
        uint32 frameDataOffs <format=hex>;
        uint32 unpackDataOffs <format=hex>;
    } else {
        uint32 frameRate;
        float  maxFrame;
        uint64 frameIndOffs <format=hex>;
        uint64 frameDataOffs <format=hex>;
        uint64 unpackDataOffs <format=hex>;
    }

    local ubyte cmprssn <name="Track compression type"> = flags >> 20;
    local uint keyFrameDataType <format=hex> = flags & 0xF00000;
    local uint compression <format=hex> = flags & 0xFF000;
    local uint trackType <format=hex> = flags & 0xFFF;

};

typedef struct framedatatrns (uint32 keyCount, uint32 flags, uint64 frameDataOffs, uint64 unpackDataOffs, uint64 frameIndOffs) {
    if (frameIndOffs > 0) {
        FSeek(frameIndOffs);
        keys KEYS(keyCount, flags, frameDataOffs);
    }
    if (unpackDataOffs > start){
        FSeek(unpackDataOffs);
        float unpackData[8];
        pos2 = FTell();
    }
    FSeek(frameDataOffs);
    struct (uint32 keyCount, uint32 flags) {
        for (frame = 0; frame < keyCount; frame++){
            struct TFRAME (uint32 flags) {
                if (exists(KEYS)) local int Time = KEYS.frameIndex[frame];
                switch (flags & 0xFF000)
                {
                    case 0x00000: //LoadVector3sFull
                        VectorFull TranslationX, TranslationZ, TranslationY;
                        break;

                    case 0x20000:
                        ushort TranslationData; if (SKIP_UNPACK) break;
                        if (MOT_HEADER.version == 65 || MOT_HEADER.version == 43) { //LoadVector3s5BitA RE2
                            local float X = unpackData[0] * (((TranslationData >> 00) & 0x1F) * (1.0f / 0x1F)) + unpackData[4];
                            local float Y = unpackData[1] * (((TranslationData >> 05) & 0x1F) * (1.0f / 0x1F)) + unpackData[5];
                            local float Z = unpackData[2] * (((TranslationData >> 10) & 0x1F) * (1.0f / 0x1F)) + unpackData[6];
                        } else {                        //LoadVector3s5BitB RE3
                            local float X = unpackData[0] * (((TranslationData >> 00) & 0x1F) * (1.0f / 0x1F)) + unpackData[3];
                            local float Y = unpackData[1] * (((TranslationData >> 05) & 0x1F) * (1.0f / 0x1F)) + unpackData[4];
                            local float Z = unpackData[2] * (((TranslationData >> 10) & 0x1F) * (1.0f / 0x1F)) + unpackData[5];
                        }
                        break;

                    case 0x50000:                       //LoadVector3s5BitUnpadded Pragmata
                        uint64 TranslationData; FSkip(-3); if (SKIP_UNPACK) break;
                        // local float N13_1 = ((TranslationData >> 00) & 0x1FFF) * (1.0f / 0x1FFF);
                        // local float N13_2 = ((TranslationData >> 13) & 0x1FFF) * (1.0f / 0x1FFF);
                        // local float N13_3 = ((TranslationData >> 26) & 0x1FFF) * (1.0f / 0x1FFF);

                        // local float N20_1 = ((TranslationData >> 00) & 0xFFFFF) * (1.0f / 0xFFFFF);
                        // local float N20_2 = ((TranslationData >> 20) & 0xFFFFF) * (1.0f / 0xFFFFF);

                        local float B0 = ((TranslationData >> 0) & 0xFF)  * (1.0f / 0xFF); // plausible
                        local float B1 = ((TranslationData >> 8) & 0xFF)  * (1.0f / 0xFF); // unlikely
                        local float B2 = ((TranslationData >> 16) & 0xFF) * (1.0f / 0xFF); // unlikely
                        local float B3 = ((TranslationData >> 24) & 0xFF) * (1.0f / 0xFF); // unlikely
                        local float B4 = ((TranslationData >> 32) & 0xFF) * (1.0f / 0xFF); // v unlikely

                        local float BH0 = ((TranslationData >> 0) & 0xFFF)  * (1.0f / 0xFFF); // unlikely
                        local float BH1 = ((TranslationData >> 8) & 0xFFF)  * (1.0f / 0xFFF); // unlikely
                        local float BH2 = ((TranslationData >> 12) & 0xFFF) * (1.0f / 0xFFF); // unlikely
                        local float BH3 = ((TranslationData >> 16) & 0xFFF) * (1.0f / 0xFFF); // maybe?
                        local float BH4 = ((TranslationData >> 20) & 0xFFF) * (1.0f / 0xFFF); // unlikely
                        local float BH5 = ((TranslationData >> 24) & 0xFFF) * (1.0f / 0xFFF); // unlikely
                        local float BH6 = ((TranslationData >> 28) & 0xFFF) * (1.0f / 0xFFF); // unlikely

                        local float S0 = ((TranslationData >> 0) & 0xFFFF)  * (1.0f / 0xFFFF); // unlikely
                        local float S1 = ((TranslationData >> 8) & 0xFFFF)  * (1.0f / 0xFFFF); // unlikely
                        local float S2 = ((TranslationData >> 16) & 0xFFFF) * (1.0f / 0xFFFF); // unlikely
                        local float S3 = ((TranslationData >> 24) & 0xFFFF) * (1.0f / 0xFFFF); // plausible

                        local float T0 = ((TranslationData >> 0) & 0xFFFFFF)  * (1.0f / 0xFFFFFF); // unlikely
                        local float T1 = ((TranslationData >> 8) & 0xFFFFFF)  * (1.0f / 0xFFFFFF); // unlikely
                        local float T2 = ((TranslationData >> 16) & 0xFFFFFF) * (1.0f / 0xFFFFFF); // unlikely

                        local float V13A_0 = ((TranslationData >> 0) & 0x1FFF)  * (1.0f / 0x1FFF); // v unlikely
                        local float V13A_1 = ((TranslationData >> 13) & 0x1FFF) * (1.0f / 0x1FFF); // unlikely
                        local float V13A_2 = ((TranslationData >> 26) & 0x1FFF) * (1.0f / 0x1FFF); // maybe

                        local float V13B_0 = ((TranslationData >> 8) & 0x1FFF)  * (1.0f / 0x1FFF); // unlikely
                        local float V13B_1 = ((TranslationData >> 21) & 0x1FFF) * (1.0f / 0x1FFF); // unlikely

                        local float X = unpackData[0] * (((TranslationData >> 00) & 0x1FFF) * (1.0f / 0x1FFF)) + unpackData[3];
                        local float Y = unpackData[1] * (((TranslationData >> 13) & 0x1FFF) * (1.0f / 0x1FFF)) + unpackData[4];
                        local float Z = unpackData[2] * (((TranslationData >> 26) & 0x1FFF) * (1.0f / 0x1FFF)) + unpackData[5];
                        break;

                    case 0x34000:
                        if (MOT_HEADER.version == 65) { //LoadScalesXYZ RE2
                            float X;
                            local float Y = X;
                            local float Z = X;
                            break;
                        }

                    case 0x30000:                       //LoadVector3s10BitA RE2
                        if (MOT_HEADER.version == 78) { //LoadVector3s5BitB RE3
                            ushort TranslationData;  if (SKIP_UNPACK) break;
                            local float X = unpackData[0] * (((TranslationData >> 00) & 0x1F) * (1.0f / 0x1F)) + unpackData[3];
                            local float Y = unpackData[1] * (((TranslationData >> 05) & 0x1F) * (1.0f / 0x1F)) + unpackData[4];
                            local float Z = unpackData[2] * (((TranslationData >> 10) & 0x1F) * (1.0f / 0x1F)) + unpackData[5];
                            break;
                        }
                    case 0x40000:
                        uint32 TranslationData; if (SKIP_UNPACK) break;
                        if (MOT_HEADER.version == 65 || MOT_HEADER.version == 43) { //LoadVector3s10BitA RE2
                            local float X = unpackData[0] * (((TranslationData >> 00) & 0x3FF) * (1.0f / 0x3FF)) + unpackData[4]; //x
                            local float Y = unpackData[1] * (((TranslationData >> 10) & 0x3FF) * (1.0f / 0x3FF)) + unpackData[5]; //y
                            local float Z = unpackData[2] * (((TranslationData >> 20) & 0x3FF) * (1.0f / 0x3FF)) + unpackData[6]; //z
                        } else {                        //LoadVector3s10BitB RE3
                            local float X = unpackData[0] * (((TranslationData >> 00) & 0x3FF) * (1.0f / 0x3FF)) + unpackData[3]; //w
                            local float Y = unpackData[1] * (((TranslationData >> 10) & 0x3FF) * (1.0f / 0x3FF)) + unpackData[4]; //x
                            local float Z = unpackData[2] * (((TranslationData >> 20) & 0x3FF) * (1.0f / 0x3FF)) + unpackData[5]; //y
                        }
                        break;

                    case 0x60000:                       //LoadVector3s24Bit  Pragmata
                        uint16 TranslationData[3]; if (SKIP_UNPACK) break;
                        local float X = unpackData[0] * (((TranslationData[0]) & 0xFFFF) * (1.0f / 0xFFFF)) + unpackData[3];
                        local float Y = unpackData[1] * (((TranslationData[1]) & 0xFFFF) * (1.0f / 0xFFFF)) + unpackData[4];
                        local float Z = unpackData[2] * (((TranslationData[2]) & 0xFFFF) * (1.0f / 0xFFFF)) + unpackData[5];
                        break;

                    case 0x70000:                       //LoadVector3s18Bit
                        if (MOT_HEADER.version >= 78) {
                            // LoadVector3s18Bit OK for pragmata
                            uint64 TranslationData; FSkip(-1); if (SKIP_UNPACK) break;
                            local float X = (unpackData[0] * ((TranslationData >> 00) & 0x3FFFF) / 262143.0f) + unpackData[3];
                            local float Y = (unpackData[1] * ((TranslationData >> 18) & 0x3FFFF) / 262143.0f) + unpackData[4];
                            local float Z = (unpackData[2] * ((TranslationData >> 36) & 0x3FFFF) / 262143.0f) + unpackData[5];
                        } else {
                            //LoadVector3s21BitA  RE2 TODO verify
                            uint64 TranslationData; if (SKIP_UNPACK) break;
                            local float X = unpackData[0] * (((TranslationData >> 00) & 0x1FFFFF) / 2097151.0f) + unpackData[4];
                            local float Y = unpackData[1] * (((TranslationData >> 21) & 0x1FFFFF) / 2097151.0f) + unpackData[5];
                            local float Z = unpackData[2] * (((TranslationData >> 42) & 0x1FFFFF) / 2097151.0f) + unpackData[6];
                        }
                        break;

                    case 0x80000:                       //LoadVector3s21BitB  RE3
                        uint64 TranslationData; if (SKIP_UNPACK) break;
                        local float X = unpackData[0] * (((TranslationData >> 00) & 0x1FFFFF) / 2097151.0f) + unpackData[3];
                        local float Y = unpackData[1] * (((TranslationData >> 21) & 0x1FFFFF) / 2097151.0f) + unpackData[4];
                        local float Z = unpackData[2] * (((TranslationData >> 42) & 0x1FFFFF) / 2097151.0f) + unpackData[5];
                        break;

                    case 0x31000:                       //LoadVector3sXAxis RE2
                    case 0x41000:                       // RE3
                        float X;
                        local float Y = unpackData[1];
                        local float Z = unpackData[2];
                        break;

                    case 0x32000:                       //LoadVector3sYAxis RE2
                    case 0x42000:                       // RE3
                        local float X = unpackData[0];
                        float Y;
                        local float Z = unpackData[2];
                        break;

                    case 0x33000:
                        if (MOT_HEADER.version >= 993) { // WhateverThisIs Pragmata
                            ubyte TranslationData[3]; if (SKIP_UNPACK) break;  // TODO
                            local uint32 EndianSwapped = (TranslationData[2] | ((uint)(TranslationData[1]) << 8) | ((uint)(TranslationData[0]) << 16));
                            local float X = unpackData[1];
                            local float Y = unpackData[2];
                            // local float Z = unpackData[0] * ((TranslationData & 0xFFF) * (1.0f / 0xFFF)) + unpackData[3];
                            local float Z = unpackData[0] * (EndianSwapped * (1.0f / 0xFFFFFF)) + unpackData[3];
                            break;
                        }
                        //LoadVector3sZAxis RE2
                    case 0x43000:                       // RE3
                        local float X = unpackData[0];
                        local float Y = unpackData[1];
                        float Z;
                        break;

                    case 0x37000: // LoadVector3s3ByteUknPragmata TODO
                        ubyte TranslationData[3];
                        local float X = unpackData[0] * (((TranslationData[0]) & 0xFF) * (1.0f / 0xFF)) + unpackData[3];
                        local float Y = unpackData[1] * (((TranslationData[1]) & 0xFF) * (1.0f / 0xFF)) + unpackData[4];
                        local float Z = unpackData[2] * (((TranslationData[2]) & 0xFF) * (1.0f / 0xFF)) + unpackData[4];
                        break;

                    case 0x27000:                       //LoadVector3sXYAxis8Bit
                        ubyte TranslationData[2]; if (SKIP_UNPACK) break;
                        local float X = unpackData[0] * (TranslationData[0] * (1.0f / 0xFF)) + unpackData[1];
                        local float Y = unpackData[2] * (TranslationData[1] * (1.0f / 0xFF)) + unpackData[3];
                        local float Z = unpackData[4];
                        break;

                    case 0x21000:                       //LoadVector3sXAxis16Bit
                        ushort TranslationData; if (SKIP_UNPACK) break;
                        local float X = unpackData[0] * (TranslationData / 65535.0f) + unpackData[1];
                        local float Y = unpackData[2];
                        local float Z = unpackData[3];
                        break;

                    case 0x22000:                       //LoadVector3sYAxis16Bit
                        ushort TranslationData; if (SKIP_UNPACK) break;
                        local float X = unpackData[1];
                        local float Y = unpackData[0] * (TranslationData / 65535.0f) + unpackData[2];
                        local float Z = unpackData[3];
                        break;

                    case 0x23000:                       //LoadVector3sZAxis16Bit
                        ushort TranslationData; if (SKIP_UNPACK) break;
                        local float X = unpackData[1];
                        local float Y = unpackData[2];
                        local float Z = unpackData[0] * (TranslationData / 65535.0f) + unpackData[3];
                        break;

                    case 0x24000:                       //LoadVector3sXYZAxis16Bit RE3
                        ushort TranslationData; if (SKIP_UNPACK) break;
                        local float X, Y, Z = unpackData[0] * (TranslationData / 65535.0f) + unpackData[3];
                        break;

                    case 0x44000:                       //LoadVector3sXYZAxis RE3
                        float TranslationData;
                        local float X, Y, Z = TranslationData;
                        break;

                    case 0x45000:                       //LoadVector3sYZAxis16Bit TODO
                    case 0x46000:                       //LoadVector3sXZAxis16Bit TODO
                    case 0x47000:                       //LoadVector3sXYAxis16Bit
                        uint16 TranslationData[2]; if (SKIP_UNPACK) break;
                        local float X = unpackData[0] * (TranslationData[0] * (1.0f / 0xFFFF)) + unpackData[1];
                        local float Y = unpackData[2] * (TranslationData[1] * (1.0f / 0xFFFF)) + unpackData[3];
                        local float Z = unpackData[4];
                        break;

                    case 0x55000:                       //LoadVector3sXYAxis20Bit
                        uint64 TranslationData; FSkip(-3); if (SKIP_UNPACK) break;
                        local float Val1 = (TranslationData & 0xFFFFF) * (1.0f / 0xFFFFF);
                        local float Val2 = ((TranslationData >> 20) & 0xFFFFFF) * (1.0f / 0xFFFFFF);
                        local float X = unpackData[0] * (((TranslationData >> 00) & 0xFFFFF) * (1.0f / 0xFFFFF)) + unpackData[2];
                        local float Y = unpackData[1] * (((TranslationData >> 20) & 0xFFFFF) * (1.0f / 0xFFFFF)) + unpackData[3];
                        local float Z = unpackData[4];
                        break;
                    case 0x56000:                       //LoadVector3sXZAxis20Bit
                        uint64 TranslationData; FSkip(-3); if (SKIP_UNPACK) break;
                        local float X = unpackData[0] * (((TranslationData >> 00) & 0xFFFFF) * (1.0f / 0xFFFFF)) + unpackData[2];
                        local float Y = unpackData[1] * (((TranslationData >> 20) & 0xFFFFF) * (1.0f / 0xFFFFF)) + unpackData[3];
                        local float Z = unpackData[4];
                        break;
                    case 0x57000:                       //LoadVector3sZXAxis20Bit
                        uint64 TranslationData; FSkip(-3); if (SKIP_UNPACK) break;
                        local float X = unpackData[1] * (((TranslationData >> 20) & 0xFFFFF) * (1.0f / 0xFFFFF)) + unpackData[2];
                        local float Y = unpackData[3];
                        local float Z = unpackData[0] * (((TranslationData >> 00) & 0xFFFFF) * (1.0f / 0xFFFFF)) + unpackData[4];
                        break;

                    case 0x85000:                       //LoadVector3sUknPragmata1
                        float TranslationData[2]; if (SKIP_UNPACK) break;
                        local float X = TranslationData[0] + unpackData[0];
                        local float Y = TranslationData[1] + unpackData[1];
                        local float Z = unpackData[2];
                        break;
                    case 0x86000:                       //LoadVector3sUknPragmata2
                        float TranslationData[2]; if (SKIP_UNPACK) break;
                        local float X = TranslationData[0] + unpackData[0];
                        local float Y = unpackData[1];
                        local float Z = TranslationData[1] + unpackData[2];
                        break;
                    case 0x87000:                       //LoadVector3sUknPragmata3
                        float TranslationData[2]; if (SKIP_UNPACK) break;
                        // local float X = unpackData[2] * (((TranslationData >> 00) & 0x1FFFFF) * (1.0f / 0x1FFFFF));
                        // local float Num0_21 = (((TranslationData >> 00) & 0x1FFFFF) * (1.0f / 0x1FFFFF));
                        // local float Num21_42 = (((TranslationData >> 21) & 0x1FFFFF) * (1.0f / 0x1FFFFF));
                        // local float Num42_63 = (((TranslationData >> 42) & 0x1FFFFF) * (1.0f / 0x1FFFFF));
                        local float X = unpackData[0];
                        local float Y = TranslationData[0] + unpackData[1];
                        local float Z = TranslationData[1] + unpackData[2];
                        // local float Y = unpackData[1] + (((TranslationData >> 21) & 0x1FFFFF) * (1.0f / 0x1FFFFF));
                        // local float Z = unpackData[2] * (((TranslationData >> 42) & 0x1FFFFF) * (1.0f / 0x1FFFFF)) + unpackData[1];
                        break;

                    default:
                        Printf("Unknown Translation Type: %x at FTell %d\n", (flags & 0xFF000), FTell());
                }
            } Frame (flags) <read=ReadTFrame>;
        }
    } Frames (keyCount, flags);
    if (unpackDataOffs > start) FSeek(pos2);
};

float wRot () {
    local float RotationW = 1.0f - (RotationX * RotationX + RotationY * RotationY + RotationZ * RotationZ);
    if (RotationW > 0.0f) RotationW = (float)Sqrt(RotationW);
    else RotationW = 0.0f;
    return RotationW;
}

typedef struct framedatarot (uint32 keyCount, uint32 flags, uint64 frameDataOffs, uint64 unpackDataOffs, uint64 frameIndOffs) {
    if (frameIndOffs > 0) {
        FSeek(frameIndOffs);
        keys KEYS(keyCount, flags, frameDataOffs);
    }
    if (unpackDataOffs > start) {
        FSeek(unpackDataOffs);
        float MaxUnpackX, MaxUnpackY, MaxUnpackZ, MaxUnpackW;
		if (FTell() + 16 > FileSize()) {
			local float MinUnpackX, MinUnpackY, MinUnpackZ, MinUnpackW;
		} else {
			float MinUnpackX; //todo: fix this
			float MinUnpackY;
			float MinUnpackZ;
			float MinUnpackW;
		}
        pos2 = FTell();
    }

    FSeek(frameDataOffs);
    struct (uint32 keyCount, uint32 flags) {
        for (frame = 0; frame < keyCount; frame++){
            //if (SKIP_UNPACK)
            //    break;
            struct FRAME (uint32 flags) {
                if (exists(KEYS)) local int Time = KEYS.frameIndex[frame];
                switch (flags & 0xFF000)
                {
                    case 0x00000:                       //LoadQuaternionsFull
                        float RotationX, RotationY, RotationZ, RotationW;
                        break;

                    case 0xB0000:                       //LoadQuaternions3Component
                    case 0xC0000:
                        float RotationX;
                        float RotationY;
                        float RotationZ; if (SKIP_UNPACK) break;
                        local float RotationW = wRot();
                        break;

                    case 0x20000:                       //LoadQuaternions5Bit RE3
                        ushort RotationData; if (SKIP_UNPACK) break;
                        local float RotationX = (MaxUnpackX * ((RotationData >> 00) & 0x1F) * (1.0f / 0x1F)) + MinUnpackX;
                        local float RotationY = (MaxUnpackY * ((RotationData >> 05) & 0x1F) * (1.0f / 0x1F)) + MinUnpackY;
                        local float RotationZ = (MaxUnpackZ * ((RotationData >> 10) & 0x1F) * (1.0f / 0x1F)) + MinUnpackZ;
                        local float RotationW = wRot();
                        break;

                    case 0x21000:                       //LoadQuaternionsXAxis16Bit
                        ushort RotationData; if (SKIP_UNPACK) break;
                        local float RotationX = MaxUnpackY * (RotationData / 65535.0) + MaxUnpackX;
                        local float RotationY = 0.0f;
                        local float RotationZ = 0.0f;
                        local float RotationW = wRot();
                        break;

                    case 0x22000:                       //LoadQuaternionsYAxis16Bit
                        ushort RotationData; if (SKIP_UNPACK) break;
                        local float RotationX = 0.0f;
                        local float RotationY = MaxUnpackY * (RotationData / 65535.0) + MaxUnpackX;
                        local float RotationZ = 0.0f;
                        local float RotationW = wRot();
                        break;

                    case 0x23000:                       //LoadQuaternionsZAxis16Bit
                        ushort RotationData; if (SKIP_UNPACK) break;
                        local float RotationX = 0.0f;
                        local float RotationY = 0.0f;
                        local float RotationZ = MaxUnpackY * (RotationData / 65535.0) + MaxUnpackX;
                        local float RotationW = wRot();
                        break;

                    case 0x30000:                       //LoadQuaternions10Bit RE2
                        if (MOT_HEADER.version == 78 || MOT_HEADER.version >= 458) { //LoadQuaternions8Bit RE3+
                            ubyte RotationDataX, RotationDataY, RotationDataZ; if (SKIP_UNPACK) break;
                            local float RotationX = (MaxUnpackX * (RotationDataX * 0.000015259022f)) + MinUnpackX;
                            local float RotationY = (MaxUnpackY * (RotationDataY * 0.000015259022f)) + MinUnpackY;
                            local float RotationZ = (MaxUnpackZ * (RotationDataZ * 0.000015259022f)) + MinUnpackZ;
                            local float RotationW = wRot();
                            break;
                        }
                    case 0x40000:                       //LoadQuaternions10Bit RE3
                        BitfieldDisablePadding();
                        ushort x : 10;
                        ushort y : 10;
                        ushort z : 10;
                        FSeek(startof(this));
                        uint32 RotationData; if (SKIP_UNPACK) break;
                        /*local float RotationX = (MaxUnpackX * ((RotationData >> 00) & 0x3FF) / 1023.0f) + MinUnpackX;
                        local float RotationY = (MaxUnpackY * ((RotationData >> 10) & 0x3FF) / 1023.0f) + MinUnpackY;
                        local float RotationZ = (MaxUnpackZ * ((RotationData >> 20) & 0x3FF) / 1023.0f) + MinUnpackZ;
                        local float RotationW = wRot();*/

                        local float RotationX = (MaxUnpackX * ((x) & 0x3FF) / 1023.0f) + MinUnpackX;
                        local float RotationY = (MaxUnpackY * ((y) & 0x3FF) / 1023.0f) + MinUnpackY;
                        local float RotationZ = (MaxUnpackZ * ((z) & 0x3FF) / 1023.0f) + MinUnpackZ;
                        local float RotationW = wRot();

                        break;

                    case 0x31000:                       //LoadQuaternionsXAxis
                    case 0x41000:
                        float RotationX;
                        local float RotationY = 0.0f;
                        local float RotationZ = 0.0f; if (SKIP_UNPACK) break;
                        local float RotationW = wRot();
                        break;

                    case 0x32000:                       //LoadQuaternionsYAxis
                    case 0x42000:
                        local float RotationX = 0.0f;
                        float RotationY;
                        local float RotationZ = 0.0f; if (SKIP_UNPACK) break;
                        local float RotationW = wRot();
                        break;

                    case 0x33000:                       //LoadQuaternionsZAxis
                    case 0x43000:
                        local float RotationX = 0.0f;
                        local float RotationY = 0.0f;
                        float RotationZ; if (SKIP_UNPACK) break;
                        local float RotationW = wRot();
                        break;

                    case 0x50000:                       //LoadQuaternions16Bit RE2
                        if (MOT_HEADER.version == 78 || MOT_HEADER.version >= 458) { //LoadQuaternions13Bit RE3
                            BitfieldDisablePadding(); BitfieldLeftToRight();
                            uint64 RotationData : 40; if (SKIP_UNPACK) break;
                            local float RotationX = (MaxUnpackX * ((RotationData >> 00) & 0x1FFF) * 0.00012208521f) + MinUnpackX;
                            local float RotationY = (MaxUnpackY * ((RotationData >> 13) & 0x1FFF) * 0.00012208521f) + MinUnpackY;
                            local float RotationZ = (MaxUnpackZ * ((RotationData >> 26) & 0x1FFF) * 0.00012208521f) + MinUnpackZ;
                            local float RotationW = wRot();
                            BitfieldEnablePadding(); BitfieldRightToLeft();
                            break;
                        }
                    case 0x60000:                       //LoadQuaternions16Bit RE3
                        if (MOT_HEADER.version >= 991) {
                            // TODO Pragmata needs endian flip
                        }
                        ushort RotationDataX, RotationDataY, RotationDataZ; if (SKIP_UNPACK) break;
                        local float RotationX = (MaxUnpackX * (RotationDataX / 65535.0f) + MinUnpackX);
                        local float RotationY = (MaxUnpackY * (RotationDataY / 65535.0f) + MinUnpackY);
                        local float RotationZ = (MaxUnpackZ * (RotationDataZ / 65535.0f) + MinUnpackZ);
                        local float RotationW = wRot();
                        break;

                    case 0x70000:                       //LoadQuaternions21Bit RE2
                        if (MOT_HEADER.version >= 78) { //LoadQuaternions18Bit RE3
                            // NOTE: unsure if this matches correctly for all games; it is correct for DD2
                            // could be different comrpession in earlier games? is 18 bit in DD2 as the name also implies; was it ever actually 13?
                            uint64 RotationData : 56; if (SKIP_UNPACK) break;
                            local float RotationX = (MaxUnpackX * ((RotationData >> 00) & 0x3FFFF) / 262143.0f) + MinUnpackX;
                            local float RotationY = (MaxUnpackY * ((RotationData >> 18) & 0x3FFFF) / 262143.0f) + MinUnpackY;
                            local float RotationZ = (MaxUnpackZ * ((RotationData >> 36) & 0x3FFFF) / 262143.0f) + MinUnpackZ;
                            local float RotationW = wRot();
                            break;
                        }
                    case 0x80000:                       //LoadQuaternions21Bit RE3
                        /*BitfieldDisablePadding(); BitfieldLeftToRight();
                        uint64 RotationX : 21 <read=ReadQuaternions21Bit>;
                        uint64 RotationY : 21 <read=ReadQuaternions21Bit>;
                        uint64 RotationZ : 21 <read=ReadQuaternions21Bit>;
                        uint64 RotationW : 21 <read=ReadQuaternions21Bit>;
                        BitfieldEnablePadding(); BitfieldRightToLeft(); */
                        uint64 RotationData; if (SKIP_UNPACK) break;
                        local float RotationX = (MaxUnpackX * ((RotationData >> 00) & 0x1FFFFF) / 2097151.0f) + MinUnpackX;
                        local float RotationY = (MaxUnpackY * ((RotationData >> 21) & 0x1FFFFF) / 2097151.0f) + MinUnpackY;
                        local float RotationZ = (MaxUnpackZ * ((RotationData >> 42) & 0x1FFFFF) / 2097151.0f) + MinUnpackZ;
                        local float RotationW = wRot();
                        //Printf(asdf);
                        break;
                    default:
                        Printf("Unknown Rotation Type: %x at FTell %d\n", (flags & 0xFF000), FTell());
                }
            } Frame (flags) <read=ReadFrame>;
        }
    } Frames (keyCount, flags);
    if (unpackDataOffs > start) FSeek(pos2);
};

typedef struct framedatafloat (uint32 keyCount, uint32 flags, uint64 frameDataOffs, uint64 unpackDataOffs, uint64 frameIndOffs) {
    if (frameIndOffs > 0) {
        FSeek(frameIndOffs);
        keys KEYS(keyCount, flags, frameDataOffs);
    } else int a;
    if (unpackDataOffs > start) {
        FSeek(unpackDataOffs);
        float MaxUnpackX, MaxUnpackY, MaxUnpackZ, MaxUnpackW;
		if (FTell() + 16 > FileSize()) {
			local float MinUnpackX, MinUnpackY, MinUnpackZ, MinUnpackW;
		} else {
			float MinUnpackX; //todo: fix this
			float MinUnpackY;
			float MinUnpackZ;
			float MinUnpackW;
		}
        pos2 = FTell();
    }

    FSeek(frameDataOffs);
    struct (uint32 keyCount, uint32 flags) {
        for (frame = 0; frame < keyCount; frame++){
            //if (SKIP_UNPACK)
            //    break;
            struct FFRAME (uint32 flags) {
                if (exists(KEYS)) local int Time = KEYS.frameIndex[frame];
                switch (flags & 0xFF000)
                {
                    case 0x00000:                       //LoadFloatsFull
                        float Value;
                        break;

                    default:
                        float Value;
                        Printf("Unknown Float compression Type: %x at FTell %d\n", (flags & 0xFF000), FTell());
                }
            } Frame (flags) <read=ReadFFrame>;
        }
    } Frames (keyCount, flags);
    if (unpackDataOffs > start) FSeek(pos2);
};

string ReadTFrame(TFRAME &f) {
    local string s;
    SPrintf(s, "%g", f.Time);
    return s;
}

string ReadFrame(FRAME &f) {
    local string s;
    SPrintf(s, "%g", f.Time);
    return s;
}

string ReadFFrame(FFRAME &f) {
    local string s;
    SPrintf(s, "%g", f.Time);
    return s;
}

/*string ReadQuaternions21Bit(uint64 &q) {
    local string s;
    SPrintf(s, "%g\n", (parentof(parentof(parentof(q))).MaxUnpack[] * (q / 2097151.0f)) + parentof(parentof(parentof(q))).MinUnpack[]);
    return s;
}*/

typedef struct {
    uint64 Address <format=hex>;
    if (Address == 0) {
        local string motName = "";
    } else if (ReadUInt(Address+4) == 1701999725) {
        local string motName = ReadWString(Address + ReadUInt64(Address + 48));
    } else if (HEADER.version == 486) {
        local string motName = ReadWString(Address + ReadUInt64(Address + 88));
    } else
        local string motName = ReadWString(Address + 116);

    FSeek(startof(Address)+8);
    if (Address == 0) motName = "";
} POINTERS <read=ReadPOINTERS, write=WritePOINTERS, name=ReadPOINTERSNAME>;
    string ReadPOINTERSNAME (POINTERS &input) { return input.motName; }
    string ReadPOINTERS (POINTERS &input) { string s; SPrintf(s, "%u", input.Address); return s; }
    void WritePOINTERS (POINTERS &input, string s) { input.Address = Atoi(s); }

typedef struct motHdr {
    uint    version;
    char    ID[4];
    uint32  ukn00;
    uint32  motSize;
    uint64  offsToBoneHdrOffs <format=hex>;       //BoneBaseDataPointer
    uint64  boneClipHdrOffs <format=hex>;    //BoneDataPointer
    uint64  motTracksOffset <format=hex>;
    uint64  zero;
    uint64  clipFileOffset;
    uint64  jmapOffset;
    uint64  motEndClipDataOffset;
    if (version >= 456) {
        uint64  motEndClipFrameValuesOffset;
    }
    uint64  motPropertyTreeOffset;

    uint64  namesOffs <format=hex>;
    float   frameCount;
    local int firstFrame = runningTotal;
    runningTotal += frameCount;
    float   blending <comment="Set to 0 to enable repeating">;
    float   uknFloat;
    float   uknFloat;
    ushort  boneCount;
    ushort  boneClipCount;
    ubyte   clipCount;
    ubyte   motEndClipCount;
    if (version >= 458) {
        ushort uknExtraCount;
    }
    ushort  FrameRate;
    ushort  motPropertyCount;
    ushort  uknShort;
    if (namesOffs) {
	    FSeek(namesOffs+start);
        wstring MOT_NAME <open=suppress>;
        FSeek(startof(uknShort)+2);
    } else
        local wstring MOT_NAME = "";
};

typedef struct  {
    uint64 boneNameOffs <format=hex>;
    local int position <hidden=true> = FTell() ;
    FSeek(boneNameOffs + start);
    wstring boneName <open=suppress>;
    FSeek(position);
    uint64 parentOffs <format=hex>;
    uint64 childOffs <format=hex>;
    uint64 nextSiblingOffs <format=hex>;
    float  translation[4] <open=suppress>;
    float  quaternion[4] <open=suppress>;
    uint32 Index;
    uint   boneHash;    //MurMur3
    uint64 padding;
} bnHdr <read=ReadBNHDR>;
    string ReadBNHDR ( bnHdr &input ) { return input.boneName; }

typedef struct {
    wstring String <open=suppress>;
} BONENAME <read=ReadBONENAME>;
    string ReadBONENAME (BONENAME &input) { return input.String; }

typedef struct {
    if (MOT_HEADER.version == 65)
    {
        ushort    boneIndex;
        trckFlg_t trackFlags; // flags for type: translations ?+    rotations xor scales
        uint8   uknFlags;
        uint32      boneHash <format=hex>;  // MurMur3
        float     uknFloat;  // always 1.0?
        uint32     padding;
        uint64 trackHdrOffs <format=hex>; //keysPointer
    }
    else
    {
        ushort    boneIndex;
        trckFlg_t trackFlags;
        uint8    uknFlags;
        uint      boneHash <format=hex>;
        if  (MOT_HEADER.version == 43)
            uint64 trackHdrOffs <format=hex>; //keysPointer
        else
            uint32 trackHdrOffs <format=hex>;
    }

    local string name <hidden=true> = "";
    if (exists(BONE_HEADERS.BONE_HEADER[boneIndex].boneName))
        name = BONE_HEADERS.BONE_HEADER[boneIndex].boneName;
    else if (exists(MOT[boneHeadersIdx].BONE_HEADERS.BONE_HEADER[boneIndex].boneName))
        name = MOT[boneHeadersIdx].BONE_HEADERS.BONE_HEADER[boneIndex].boneName;
} BONECLIPHEADER <read=ReadBONECLIPHEADER>;
    string ReadBONECLIPHEADER (BONECLIPHEADER &input) { return input.name; }

typedef struct {
    local uint64 TranslationFlagOff <hidden=true> = FTell();
    if (BONE_CLIP_HEADERS.bnClipHdr[j].trackFlags & TRANSLATION)
        track trnsltn <name="Translation">;

    local uint64 RotationFlagOff <hidden=true> = FTell();
    if (BONE_CLIP_HEADERS.bnClipHdr[j].trackFlags & ROTATION)
        track rotation <name="Rotation">;

    local uint64 ScaleFlagOff <hidden=true> = FTell();
    if (BONE_CLIP_HEADERS.bnClipHdr[j].trackFlags & SCALE)
        track scale <name="Scale">;

    pos3 = FTell();

    if (BONE_CLIP_HEADERS.bnClipHdr[j].trackFlags & TRANSLATION && trnsltn.flags >= 0){ FSeek(TranslationFlagOff); LocFrameType_t TranslationType;}
    if (BONE_CLIP_HEADERS.bnClipHdr[j].trackFlags & ROTATION && rotation.flags >= 0){ FSeek(RotationFlagOff); RotFrameType_t RotationType;}
    if (BONE_CLIP_HEADERS.bnClipHdr[j].trackFlags & SCALE && scale.flags >= 0){ FSeek(ScaleFlagOff); ScaleFrameType_t ScaleType;}

    if (BONE_CLIP_HEADERS.bnClipHdr[j].trackFlags & TRANSLATION){
        if (trnsltn.frameIndOffs > 0) FSeek(trnsltn.frameIndOffs+start);
        else FSeek(trnsltn.frameDataOffs+start);
        framedatatrns Frames(trnsltn.keyCount, trnsltn.flags, trnsltn.frameDataOffs+start, trnsltn.unpackDataOffs+start, trnsltn.frameIndOffs+start)<name="Frame Data: Translation">;
    }
    if (BONE_CLIP_HEADERS.bnClipHdr[j].trackFlags & ROTATION){
        if (rotation.frameIndOffs > 0) FSeek(rotation.frameIndOffs+start);
        else FSeek(rotation.frameDataOffs+start);
        framedatarot Frames(rotation.keyCount, rotation.flags, rotation.frameDataOffs+start, rotation.unpackDataOffs+start, rotation.frameIndOffs+start)<name="Frame Data: Rotation">;
    }
    if (BONE_CLIP_HEADERS.bnClipHdr[j].trackFlags & SCALE){
        if (scale.frameIndOffs > 0) FSeek(scale.frameIndOffs+start);
        else FSeek(scale.frameDataOffs+start);
        framedatatrns Frames(scale.keyCount, scale.flags, scale.frameDataOffs+start, scale.unpackDataOffs+start, scale.frameIndOffs+start)<name="Frame Data: Scale">;
    }
    FSeek(pos3);
    local int boneIdx<name="Bone index"> = BONE_CLIP_HEADERS.bnClipHdr[j].boneIndex;
    local string name <hidden=true> = "";

    if (exists(BONE_HEADERS.BONE_HEADER[boneIdx].boneName))
        name = BONE_HEADERS.BONE_HEADER[boneIdx].boneName;
    else if (exists(MOT[boneHeadersIdx].BONE_HEADERS.BONE_HEADER[boneIdx].boneName))
        name = MOT[boneHeadersIdx].BONE_HEADERS.BONE_HEADER[boneIdx].boneName;

} TRACKS <name="TRACKS", read=ReadTRACKS>;
    string ReadTRACKS (TRACKS &input) { return input.name; }

typedef struct
{
    if (version <= 10) {
        StringRead className(-1, start, 0, 1, 0);
    }
    StringRead name(-1, start, 0, 0, 0);
    StringRead tagTbl(-1, start, 0, 0, 0);
    uint64 tagHashTbl;
    uint64 parameterTbl;
    unsigned int classNameHash;
    unsigned int nameHash;
    uint32 extraHash1;
    if (version == 13) {
        uint32 extraHash2;
    }
    ubyte tagCount;
    ubyte paramCount;
    enum <ubyte>
    {
        NodeType_Unknown = 0x0,
        NodeType_GameObject = 0x1,
        NodeType_Component = 0x2,
        NodeType_Folder = 0x3,
    } nodeType;

    ubyte flags;
    if (version == 13) {
        uint32 padding;
    }

    local uint64 pos = FTell();
    FSeek(start+parameterTbl);
    if (paramCount > 0) {
        struct PARAM {
            if (version <= 10) {
                struct StringRead Name(-1, start, 0, 1, 0);
            }
            // uint A;
            enum {
                ParamType_Bool = 0x0,
                ParamType_U8 = 0x1,
                ParamType_S8 = 0x2,
                ParamType_U16 = 0x3,
                ParamType_S16 = 0x4,
                ParamType_S32 = 0x5,
                ParamType_U32 = 0x6,
                ParamType_S64 = 0x7,
                ParamType_U64 = 0x8,
                ParamType_F32 = 0x9,
                ParamType_F64 = 0xA,
                ParamType_Str8 = 0xB,
                ParamType_Str16 = 0xC,
                ParamType_ExtraData = 0xD,
                ParamType_Hermite = 0xE,
                ParamType_Guid = 0xF,
                ParamType_Vec2 = 0x10,
                ParamType_Vec3 = 0x11,
                ParamType_Vec4 = 0x12,
                ParamType_Matrix = 0x13,
            } paramType;
            uint Hash;
            switch (paramType) {
                case ParamType_Str8:
                    struct StringRead String(-1, start, 0, 1, 0);
                    break;
                case ParamType_Str16:
                    struct StringRead String(-1, start, 0, 0, 0);
                    break;
                case ParamType_Bool:
                case ParamType_U8:
                    ubyte value;
                    break;
                case ParamType_S8:
                    byte value;
                    break;
                case ParamType_U16:
                    ushort value;
                    break;
                case ParamType_S16:
                    short value;
                    break;
                case ParamType_S32:
                    int value;
                    break;
                case ParamType_U32:
                    uint value;
                    break;
                case ParamType_S64:
                    int64 value;
                    break;
                case ParamType_U64:
                    uint64 value;
                    break;
                case ParamType_F32:
                    float value;
                    break;
                case ParamType_F64:
                    double value;
                    break;
                default:
                    int64 paramOffset;
                    break;
            }

            if (exists(paramOffset)) {
                FSeek(start + paramOffset);
                switch (paramType) {
                    case ParamType_Guid:
                        rGUID Guid;
                        break;
                    case ParamType_Vec2:
                        float vec2[2];
                        break;
                    case ParamType_Vec3:
                        float vec3[3];
                        break;
                    case ParamType_Vec4:
                        float vec4[4];
                        break;
                    case ParamType_Matrix:
                        float matrix[16];
                        break;
                    case ParamType_ExtraData:
                    case ParamType_Hermite:
                    default:
                        int64 value;
                        break;
                }

            }

            FSeek(startof(Hash)+12);

        } Param[paramCount] <read=ReadPARAM, name=ReadPARAMName, optimize=false>;
    }

    FSeek(pos);

} NodeData <read=ReadNodeData>;

    string ReadNodeData (NodeData &n) {
        if (exists(n.className.String))
            return n.className.String;
        return "";
    }

    string ReadPARAM (PARAM &p) {
        string s = "";
        if (exists(p.String))
            return p.String.String;
        if (exists(p.value))
            if (exists(p.Name) && p.Name.String == "MotionID")
                return ReadMotNodeId(p.value);
            SPrintf(s, "%g", p.value);
        return s;
    }

    string ReadPARAMName (PARAM &p) { return EnumToString(p.paramType) + " " + (exists(p.Name) ? p.Name.String : ""); }


typedef struct
{
    unsigned int inputNodeIndex;
    unsigned int inputPinNo;
    unsigned int outputNodeIndex;
    unsigned int outputPinNo;
    enum
    {
        LinkType_Unknown = 0x0,
        LinkType_Motion = 0x1,
        LinkType_Param = 0x2,
    } linkType;
    unsigned int reserved <hidden=true>;
    uint64 inputPinGuidOffs;
    uint64 outputPinGuidOffs;
    FSeek(start + inputPinGuidOffs);
    if (inputPinGuidOffs)
        rGUID inputPinGuid;
    FSeek(start + outputPinGuidOffs);
    if (outputPinGuidOffs)
        rGUID outputPinGuid;
    if (exists(Nodes.mNodeData[inputNodeIndex])) {
        FSeek(startof(Nodes.mNodeData[inputNodeIndex]));
        struct NodeData inputNode;// <size=56>;
    }
    if (exists(Nodes.mNodeData[outputNodeIndex])) {
        FSeek(startof(Nodes.mNodeData[outputNodeIndex]));
        struct NodeData outputNode;// <size=56>;
    }
    FSeek(startof(outputPinGuidOffs) + 8);
} LinkData;


//mtre
typedef struct {
    start = FTell();
    uint    version; // accounted for: 4, 5, 10, 13, 19, 20
    char    ID[4];
    FSkip(8);

    StringRead userVariablesPath(-1, start, 0, 0, 0);
    StringRead resourcePathTbl(-1, start, 0, 0, 0);

    uint64 mNodeDataTbl;
    uint64 mLinkDataTbl;

    StringRead nameStr(-1, start, 0, 0, 0);

    if (version > 14) {
        uint64 indicesOffset;
    }
    uint64 motNodeIdTbl;
    ushort motNodeCount;
    ushort linkCount;
    ushort uknCount;
    ushort uknCount;
    ushort motionsCount;
    ushort selectMotionsCount;
    ushort uknCount;
    ushort uknCount;

    if (exists(indicesOffset) && indicesOffset > 0) {
        FSeek(start + indicesOffset);
        local int indicesRealCount = (motNodeIdTbl - indicesOffset) / 4;
        // real count seems to rely on node contents and not header data
        struct { ushort n1, n2; } nodeConnectionIndices[indicesRealCount] <read=Str("%d %d", n1, n2)>; // there's more indices after sometimes; NOT linkCount;
    }

    if (motionsCount > 0) {
        FSeek(start + motNodeIdTbl);

        // real count seems to rely on node contents and not header data
        local int realMotionCount = motionsCount + (selectMotionsCount > motionsCount ? (selectMotionsCount - motionsCount) * 2 : 0);
        struct {
            if (version < 13) {
                uint16 srcId;
                uint16 remappedId;
            } else if (version == 13) {
                uint32 srcId;
                uint16 remappedId;
            } else {
                uint32 srcId;
                uint32 remappedId;
            }
        } MotionIDRemap[realMotionCount] <read=Str("%d -> %d", srcId, remappedId), optimize=true>;
    }

    if (motNodeCount > 0) {
        FSeek(start + mNodeDataTbl);
        struct {
            struct NodeData mNodeData[motNodeCount] <optimize=false>;
        } Nodes;
    }

    struct {
        for (k = 0; k < motNodeCount; k++) {
            if (ReadByte() == 0)
                break;
            struct StringRead Name(FTell(), 0, 1, 1, 0);
        }
    } NodeNames;

    FSeek(start + mLinkDataTbl);
    struct {
        struct LinkData mLinkData[linkCount] <optimize=false, read=Str("Type=%d   %d/%d : %d/%d", linkType, inputNodeIndex, inputPinNo, outputNodeIndex, outputPinNo)>;
    } Links;

} mtre <read=readmtre, name=readmtreName>;

string readmtre(mtre &m) { return m.nameStr.String; }

string readmtreName (mtre &input) {
    local string s;
    local ushort i;
    for (i=0; i<HEADER.numOffs; i++) {
        if (HEADER.Pointers[i].Address == startof(input)) {
            if (exists(MotionIDs.MotionID[i]))
                SPrintf(s, "MTRE ID: %s", ReadMotIndex(MotionIDs.MotionID[i]));
            break;
        }
    }
    return s;
}

string ReadMotNodeId(int m) {
    if (exists(MOT_INDICES)) {
        local int i;
        for (i = 0; i < HEADER.numOffs; i++) {
             if (MOT_INDICES.MOT_INDEX[i].motNumber == m)
                return ReadMotIndex(MOT_INDICES.MOT_INDEX[i]);
        }
    }
    local string s; SPrintf(s, "%i", m);
    return s;
}

string ReadMotNodeIdShort(ushort m) {
    return ReadMotNodeId((int)m);
}

//main mot struct
typedef struct {
    start = FTell();
    motHdr MOT_HEADER <open=false>;

    if (!SKIPALL) {
        if (MOT_HEADER.offsToBoneHdrOffs && ( MOT_HEADER.motSize == 0 || MOT_HEADER.motSize > MOT_HEADER.offsToBoneHdrOffs )) {
            FSeek(MOT_HEADER.offsToBoneHdrOffs+start);
            struct {
                uint64  boneHdrOffs <format=hex>;
                uint64  boneHdrCount;
                if (boneHdrCount <= 1000) {
                    bnHdr BONE_HEADER[boneHdrCount] <optimize=false>;
                    BONENAME BONE_NAME[BONE_HEADERS.boneHdrCount] <optimize=false>;
                }
            } BONE_HEADERS;
        }
        if (MOT_HEADER.boneClipCount) {
            FSeek(MOT_HEADER.boneClipHdrOffs+start);

                struct {
                    BONECLIPHEADER bnClipHdr[MOT_HEADER.boneClipCount] <optimize=false>; //, name="BONE CLIP HEADER"
                } BONE_CLIP_HEADERS; // <name="BONE CLIP HEADER">

            skipToNextLine();
            FSeek(BONE_CLIP_HEADERS.bnClipHdr[0].trackHdrOffs+start);
            struct {
                for (j = 0; j < MOT_HEADER.boneClipCount; j++)
                {
                    FSeek(BONE_CLIP_HEADERS.bnClipHdr[j].trackHdrOffs+start);
                    TRACKS tracks;
                }
            } clipTracks <name="CLIP TRACKS">;
        } else Printf("Empty mot at %u\n", FTell());
        if ( MOT_HEADER.jmapOffset > 0) {
            FSeek(MOT_HEADER.jmapOffset + start);
            if (MOT_HEADER.version==603 && findS(Lower(GetFileName()), "fac") != -1) {
                struct {
                    uint64 offs;
                    uint tableACount; // bone count
                    uint tableBCount; //frame count + 1
                    FSeek(offs + start);
                    struct {
                        struct {
                            uint64 offs;
                            FSeek(offs+start);
                            uint64 offset  <fgcolor=cAqua>;
                            uint boneHash;
                            FSkip(4);
                            struct {
                                struct {
                                    uint64 offset;
                                    FSeek(offset+start);
                                    uint layerID, b, c;
                                    float blendValue <fgcolor=cRed>;
                                    FSeek(startof(this)+8);
                                } frame[tableBCount] <optimize=false, fgcolor=cGreen >;
                            } frames;
                            FSeek(startof(this)+8);
                        } bone[tableACount] <optimize=false>;
                    } boneFrames;
                } boneFrames;
            } else
                wstring JMAP;
        }
        if (MOT_HEADER.motTracksOffset > 0) {
            FSeek(MOT_HEADER.motTracksOffset + start);
            struct {
                uint64 offset;
                uint32 propertyHash;
                uint32 padding<hidden=true>;
                local uint64 pos = FTell();
                FSeek(offset + start);
                struct {
                    uint32 flags;
                    int valueCount;
                    int frameIndOffs;
                    int frameDataOffs;
                    int unpackDataOffs;
                    if (frameIndOffs > 0) FSeek(frameIndOffs+start);
                    else FSeek(frameDataOffs+start);
                    framedatafloat Frames(valueCount, flags, frameDataOffs + start, unpackDataOffs + start, frameIndOffs + start);
                } PropertyData;
                FSeek(pos);
            } MotPropertyTracks[MOT_HEADER.motPropertyCount] <optimize=false>;
        }
    }

    local uint32 clipEnd <hidden=true>;
    if ( NOCLIP == FALSE && MOT_HEADER.clipFileOffset > 0 && MOT_HEADER.clipCount) {// && MOT_HEADER.version != 613) { //43
        FSeek(MOT_HEADER.clipFileOffset + start);
        MotlistClip CLIP;
        clipEnd = FTell();

    }

        if (exists(MOT_HEADER.motPropertyTreeOffset) && MOT_HEADER.motPropertyTreeOffset > 0) {
            FSeek(MOT_HEADER.motPropertyTreeOffset + start);
            struct {
                local uint64 treeStart = FTell();
                uint64 firstNodeOffset;
                uint64 hashesOffset;
                uint32 nodeCount, hashCount;
                uint64 padding;

                typedef struct SingleValueNode {
                    uint64 dataOffsetOrValue;
                    uint32 propertyHash;
                    uint8 type;
                    uint8 count;
                    uint16 padding<hidden=true>;
                    if (count > 0) {
                        local uint64 p = FTell();
                        FSeek(treeStart + dataOffsetOrValue);
                        uint data[count];
                        FSeek(p);
                    } else if (type == 15) {
                        local uint64 p = FTell();
                        FSeek(treeStart + dataOffsetOrValue);
                        wstring str;
                        FSeek(p);
                    }
                };
                typedef struct MultiValueNode {
                    uint64 dataOffset;
                    uint32 propertyHash;
                    uint32 count; // 1041 = quaternion?
                    uint32 zero;
                    uint32 valueType;
                    if (count > 0) {
                        local uint64 p = FTell();
                        FSeek(treeStart + dataOffset);
                        uint data[count];
                        FSeek(p);
                    }
                };
                typedef struct MotPropertyTreeNode {
                    uint64 leftOffset;
                    uint64 rightOffset;
                    uint32 countSimple;
                    uint32 countMulti;
                    uint32 nameHash;
                    uint32 nameHash2;
                    local uint64 pos = FTell();
                    if (countSimple > 0) {
                        FSeek(leftOffset + treeStart);
                        SingleValueNode simpleNodes[countSimple] <optimize=false>;
                    }
                    if (countMulti > 0) {
                        FSeek(rightOffset + treeStart);
                        MultiValueNode multiNodes[countMulti] <optimize=false>;
                    }
                    FSeek(pos);
                };

                if (nodeCount > 0) MotPropertyTreeNode Nodes[nodeCount] <optimize=false>;

                FSeek(hashesOffset + treeStart);
                struct { uint32 src; uint32 hash; } hashes[hashCount];
            } MotPropertyTree;
        }
    //find end of mot
    if (bIsMotFile)
        FSeek( FileSize() );
    else if (i == numOffs-1 && HEADER.Pointers[i].Address < HEADER.colOffs)
        FSeek(HEADER.colOffs);
    else FSeek(findNextMot(FTell()));

} mot <read=ReadMOT, name=ReadMOTName>;//, size=SizeMOT>;

    wstring ReadMOT ( mot &input ) {
        local string s;
        SPrintf(s," (%g frames)", input.MOT_HEADER.frameCount);
        local uint motVersion = ReadUInt(startof(input));

		return ReadWString(startof(input) + input.MOT_HEADER.namesOffs) + s;
	}

    string ReadMOTName (mot &input) {
        local string s;
        local ushort i;
        for (i=0; i<HEADER.numOffs; i++) {
            if (HEADER.Pointers[i].Address == startof(input)) {
                if (exists(MotionIDs.MotionID[i]))
                    SPrintf(s, "MOT ID: %s", ReadMotIndex(MotionIDs.MotionID[i]));
                break;
            }
        }
        return s;
    }

	uint SizeMOT ( mot &input ) {
		local uint posStart = FTell();
		local uint finalPosition = startof(input) + 16;
		if (ReadUInt64(startof(input) + 72))
			finalPosition = ReadUInt64(startof(input) + 72) + startof(input);
		FSeek(finalPosition);
    	while (ReadUInt(FTell()+4) != 544501613) {
			if (FTell()+18 < FileSize()) {
				if ((exists(HEADER) && FTell() >= HEADER.colOffs) && startof(input) < HEADER.colOffs) {
					FSeek(HEADER.colOffs);
					break;
				}
				if (FTell()+16 >= FileSize()) {
					FSeek(FileSize());
            		break;
				}
				FSkip(16);
			} else { FSeek(FileSize()); break;};
    	}
		finalPosition = FTell();
		FSeek(posStart);
		return finalPosition - startof(input);
		//return getMotSize(startof(input));
	}

typedef struct  {
    if (HEADER.version > 60) uint64 extraClipOffset;
    ushort motNumber;
    ushort Switch <hidden=false>;
    if (motIndexSz > 0) {
        if (HEADER.version >= 486) {
            uint ukn1;
            uint ukn2;
            ubyte ukn;
            ubyte ukn;
            ubyte ukn;
            ubyte extraClipCount;
            if (HEADER.version > 486) uint data[12];
            else uint data[3];
        } else if (HEADER.version > 60) {
            local uint extraClipCount = (extraClipOffset > 0 ? 1 : 0);
            uint data[3];
            if (extraClipOffset > 0) {
                FSeek(extraClipOffset);
                CLIP_ENTRY END_CLIP;
            }
        }

        if (exists(extraClipOffset) && extraClipOffset > 0) {
            FSeek(extraClipOffset);
            uint64 extraClipOffsets[extraClipCount];

            start = 0;
            local int c = 0;
            for (c = 0; c < extraClipCount; c++) {
                FSeek(extraClipOffsets[c]);
                if (HEADER.version >= 1057) start = FTell();
                CLIP_ENTRY END_CLIP;
            }
        }
    }
    FSeek(startof(this)+motIndexSz);
    local uint32 index <hidden=true> = i ;
} motIndex <read=ReadMotIndex, name=ReadMotIndexName>; //

    string ReadMotIndexName ( motIndex &input ) {
        return HEADER.Pointers[input.index].motName;
    }

    string ReadMotIndex ( motIndex &input ) {
        string s;
        SPrintf(s, "%u", ReadUShort(startof(input)+8));
        return s;
    }



/* ---FUNCTIONS---- */
int isInArr(int64 val, int64 arr[]){
    local int a;

    for(a = 0; a < sizeof(arr)/8; a++)
    {
        if(arr[a] == val)
            return true;
    }
    return false;
}

//General offset fixer
void FixOffsets(uint64 tell, uint64 tellLimit, uint64 insertPoint, int64 maxOffset, uint64 addedSz, int doInt32) {
    if (tell > tellLimit) {
        Printf("Cannot fix offsets: insert point %i is before start boundary %i\n", insertPoint, tell);
        return;
    }
    Printf("Fixing Offsets greater than %i and less than %i from positions %i to %i:\n\n", insertPoint, maxOffset, tell, tellLimit);
    local uint64 pos = FTell();
    local int64 tmp;
    local int varSize = 8 + -4 * (doInt32 > 0);
    FSeek(tell);
    while(FTell() + varSize <= tellLimit) {
        if (FTell()+varSize > FileSize())
            break;
        if (doInt32)
            tmp = ReadInt(FTell());
        else
            tmp = ReadInt64(FTell());
        if (tmp >= insertPoint && tmp <= maxOffset) {
            Printf("@ position %i:  %Li  >= %Li (limit %i) added +%i\n", FTell(), tmp, insertPoint, maxOffset, addedSz);
            if (doInt32)
                tmp = WriteUInt(FTell(), tmp + addedSz);
            else
                WriteUInt64(FTell(), tmp + addedSz);
        }// else //if (tmp && tmp <= maxOffset)
         //   Printf("@ position %i: %Li  >! %Li (limit %i) %i\n",  FTell(), tmp, insertPoint, tellLimit, addedSz);
        FSkip(varSize);
    }
}

/* ----START---- */
ReadBytes(bytes, 4, 4);
if (bytes == "mot ") //single .mot files
{
    bIsMotFile = 1;
    struct {
        ubyte blank;
        local int version = 99, Version = version, numOffs=0;
    } HEADER <hidden=false>; //false header
    FSkip(-1);
    local uint motVersion <hidden=true> = ReadUInt(0);
    if (motVersion == 43)
        HEADER.version = 60;
    else if (motVersion == 65)
        HEADER.version = 85;
    else if (motVersion == 78)
        HEADER.version = 99;
    else if (motVersion == 458 || motVersion == 524 || motVersion == 456 || motVersion == 492 || motVersion == 495 || motVersion == 603 || motVersion == 613 || motVersion == 698)
        HEADER.version = 486;
    HEADER.Version = HEADER.version;
    if (motVersion == 603 || motVersion == 613)
        HEADER.Version = 663;
    if (motVersion == 698)
        HEADER.Version = 751;
    mot MOT;
}
else if (NOCLIP == FALSE && ReadUInt(FTell()) == 1346980931)
{
    struct { local int version = 99; } HEADER <hidden=true>;
    CLIP_ENTRY Clip;
}
else
{
    struct {
        uint32  Version;
        local uint version <hidden=false> = Version;
        if (version == 484 || version == 524 || version == 528 || version==653)
            version = 486;
        char    ID[4];
        uint64  padding;
        uint64  pointersOffs <format=hex>; // AssetsPointer in Tyrant
        uint64  colOffs <format=hex, name="MotionID offset">;
        uint64  motListNameOffs <format=hex>; //NamePointer
        if (version > 60)
            uint64  motlistPathOffset;
        if (version > 992)
            uint64  ukn;
        uint32  numOffs; FSeek(motListNameOffs); //AssetCount
        wstring motListName <open=suppress>;
        if (exists(motlistPathOffset) && motlistPathOffset > 0) {
            FSeek(motlistPathOffset);
            wstring motListPath <open=suppress>;
        }
        FSeek(pointersOffs);
        POINTERS Pointers[numOffs] <optimize=false>;
    } HEADER;

    local uint motIndexSz <hidden=1> = (HEADER.version >= 486) ? 72 : ((HEADER.version == 60) ? 12 : 24);
    local int64 tmpArr[HEADER.numOffs] <format=hex, hidden=true>, \
                isUnique[HEADER.numOffs] <format=hex, hidden=true>;

    //count offsets without nulls and duplicates
    for (i = 0; i < HEADER.numOffs; i++)
    {
        if (HEADER.Pointers[i].Address && !isInArr(HEADER.Pointers[i].Address, tmpArr))
        {
            numOffs++;
            isUnique[i] = 1;
        }
        tmpArr[i] = HEADER.Pointers[i].Address;
    }

    //fill the array with unique non-zero offsets
    local int64 offs[numOffs] <format=hex, hidden=true>;
    for (i = 0; i < HEADER.numOffs; i++)
    {
        if (HEADER.Pointers[i].Address && isUnique[i])
        {
            offs[j] = HEADER.Pointers[i].Address;
            j++;
        }
    }

    motCounter = 0;
    local uint motMagic <hidden=true>;
    for (i = 0; i < numOffs; i++)
    {
        FSeek(offs[i]);
        motMagic = ReadUInt(FTell() + 4);

        if (motMagic == 0x6572746D)
        {
            //struct {
            //    FSeek( i < numOffs-1 ? offs[i+1] : (HEADER.colOffs > 0 ? HEADER.colOffs : FileSize) );
            //} MOT_TREE;
            SetForeColor(cGreen);
            mtre MTRE;
            SetForeColor(cNone);
        }
        else if (motMagic == 0x74736C63)
        {
            struct {
                FSeek( i < numOffs-1 ? offs[i+1] : (HEADER.colOffs > 0 ? HEADER.colOffs : FileSize) );
            } MCAM;
        }
        else
        {
            mot MOT;
            FSeek( i < numOffs-1 ? offs[i+1] : FileSize());
            motCounter++;
        }
    }

    FSeek(HEADER.colOffs);
    struct {
        for (i = 0; i < HEADER.numOffs; i++)
            motIndex MotionID;
    } MotionIDs;
    //Printf("Checking %u %u\n", FTell(), ReadUInt64(FTell()));
}
string ReadFileEnd(ubyte &u) { local string s; SPrintf(s, "%u", FileSize()); return s; }

//Printf("Number of valid entries: %d\n", numOffs);