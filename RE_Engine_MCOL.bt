//------------------------------------------------
//--- 010 Editor v9.0.2 Binary Template
//
//      File: MCOL.bt
//   Authors: shadowcookie
//   Version: 0.1
//   Purpose:
//  Category: RE Engine
// File Mask: *.mcol.*
//  ID Bytes: 4D 43 4F 4C
//   History:
//------------------------------------------------

local int version = Atoi(SubStr(FileNameGetExtension(GetFileName()), 1));

#include "common.bt";
#include "RE_BVH_common.bt";

if (version == 2) {
    Printf("Unsupported file version!\n");
}

// via.dynamics.RigidBodyMeshResourceHolder
typedef struct RBMHeader { // rmesh
	uint32 magic;
    uint32 ukn;
    uint64 bvhOffset;
    // used by via.dynamics.MeshShape
    // should / can contain:
    // vertices (vec3)
    // triangles (3x vec3)
};

// via.physics.CollisionMeshResourceHolder
typedef struct MCOLHeader {
	uint32 magic;
    uint32 bvhSize;
    uint stringCount;
    uint padding;
    if (version == 2) {
        local uint64 bvhOffset = startof(this) + 16;
    } else {
        uint64 mcolStringTableOffset;
        local uint64 bvhOffset = startof(this) + 32;
    }
    // could also contain:
    // partsEnabled - bool[]
    // triangle mask bits - uint
    // materialinfo array (via.physics.MaterialInfo - physics material - ID + 3x attributes)
    // scale, scale error
    // also via.physics.ShapeKeys  - individual uint values (shape ID / group ID?)
};

typedef struct TERRHeader {
	uint32 magic;
    uint32 ukn;
    uint count;
    uint count2;
    GUID guid;
    uint64 offset1;
    uint64 offset2;
    local uint64 bvhOffset = startof(this) + 48;
    // note: there should be a list of triangles somewhere, or at least a count
};

local int isMcol = (ReadUInt() == 0x4c4f434d);
local int isTerr = (ReadUInt() == 0x52524554);
local int isRmesh = (ReadUInt() == 0x204D4252);
if (isMcol) {
	MCOLHeader Header;
} else if (isRmesh) {
	RBMHeader Header;
} else if (isTerr) {
    TERRHeader Header;
}

if (exists(Header.bvhSize) && Header.bvhSize == 0) {
    Exit(0);
}

FSeek(Header.bvhOffset);
struct BVHHeader {
	uint32 magic;
	uint32 positionCount; // dd2 mcol
    uint32 indicesCount;
    uint32 uknCount;
    uint32 stringCount;
    uint32 spheresCount; // found in dd2
    uint32 capsulesCount;
    uint32 boxesCount;
    uint32 ukn3;

    uint32 treeDataSize;
    uint64 treeDataOffset; // data1_addr
    uint64 positionsOffset; // vertex positions?
    uint64 object2Offset;
    uint64 uknOffset;

    uint64 stringTableOffset;
    uint64 spheresOffset;
    uint64 capsulesOffset;
    uint64 boxesOffset;
    uint64 uknOffsetPadding;
} bvh <read=(exists(StringTable.name) ? StringTable.name : "")>;

if (isMcol) {
    vec3p minBounds;
    vec3p maxBounds;
}

if (bvh.treeDataSize > 0) {
    FSeek(startof(bvh) + bvh.treeDataOffset);
    BvhTree Tree;
}

if (bvh.positionCount > 0) {
    FSeek(startof(bvh) + bvh.positionsOffset);
    struct {
	    vec3p vertex[bvh.positionCount] <read=Str("%f %f %f", x, y, z)>;
    } Vertices;
}

if (bvh.indicesCount > 0) {
    FSeek(startof(bvh) + bvh.object2Offset);
    // hard separating the structs because the editor can't handle large arrays without optimizations
    struct {
        if (version >= 20021) {
            struct {
                uint32 ukn0;
                uint32 layerIndex; // corresponds to a string index in the string table
                uint32 mask;
                uint32 groupId;

                uint32 ukn1;
                uint32 ukn2;
                uint32 ukn3;
                uint32 ukn4;
                uint32 ukn5;
                uint32 ukn6;
                uint32 ukn7;

                uint32 posIdx1;
                uint32 posIdx2;
                uint32 posIdx3;
                uint32 posIdx4;
                uint32 posIdx5;
                uint32 posIdx6;
            } data[bvh.indicesCount] <read=Str("%d:%d - %x", layerIndex, groupId, mask)>;
        } else if (version >= 13020) {
            struct {
                uint32 ukn0;
                uint32 layerIndex; // corresponds to a string index in the string table
                uint32 mask;

                uint32 ukn1;
                uint32 ukn2;
                uint32 ukn3;
                uint32 ukn4;
                uint32 ukn5;
                uint32 ukn6;
                uint32 ukn7;

                uint32 posIdx1;
                uint32 posIdx2;
                uint32 posIdx3;
                uint32 posIdx4;
                uint32 posIdx5;
                uint32 posIdx6;
            } data[bvh.indicesCount] <read=Str("%d:%d - %x", layerIndex, groupId, mask)>;
        } else if (version >= 3017) {
            struct {
                uint32 ukn0;
                uint32 layerIndex; // corresponds to a string index in the string table

                uint32 ukn1;
                uint32 ukn2;
                uint32 ukn3;
                uint32 ukn4;
                uint32 ukn5;
                uint32 ukn6;
                uint32 ukn7;

                uint32 posIdx1;
                uint32 posIdx2;
                uint32 posIdx3;
                uint32 edgeIdx1;
                uint32 edgeIdx2;
                uint32 edgeIdx3;
                uint32 ukn;
            } data[bvh.indicesCount] <read=Str("%d", layerIndex)>;
        } else {
            // 2 = re7 non-rt; struct unknown for now because the header is a pain in the ass and not worth figuring out
            struct {
                uint32 ukn0;
                uint32 layerIndex; // corresponds to a string index in the string table

                uint32 ukn1;
                uint32 ukn2;
                uint32 ukn3;
                uint32 ukn4;
                uint32 ukn5;
                uint32 ukn6;
                uint32 ukn7;

                uint32 posIdx1;
                uint32 posIdx2;
                uint32 posIdx3;
                uint32 edgeIdx1;
                uint32 edgeIdx2;
                uint32 edgeIdx3;
                uint32 ukn;
            } data[bvh.indicesCount] <read=Str("%d", layerIndex)>;
        }
    } Indices;
}

if (bvh.spheresCount > 0) {
    FSeek(startof(bvh) + bvh.spheresOffset);
    struct {
        uint ukn0;
        uint layerIndex;
        uint mask;
        uint groupId;
	    vec4 vec;
    } Spheres[bvh.spheresCount] <read=Str("%d:%d %x / %f %f %f %f", layerIndex, groupId, mask, vec.x, vec.y, vec.z, vec.w), optimize=false>;
}

if (bvh.capsulesCount > 0) {
    FSeek(startof(bvh) + bvh.capsulesOffset);
    struct {
        uint ukn0;
        uint layerIndex;
        uint mask;
        uint groupId;
	    Capsule capsule;
    } Capsules[bvh.capsulesCount] <read=Str("%d:%d %x / %f %f %f", layerIndex, groupId, mask, capsule.p0.x, capsule.p0.y, capsule.p0.z), optimize=false>;
}

if (bvh.boxesCount > 0) {
    FSeek(startof(bvh) + bvh.boxesOffset);
    struct {
        uint ukn0;
        uint layerIndex;
        uint mask;
        uint groupId;
        OBB box;
    } Boxes[bvh.boxesCount] <read=Str("%d:%d %x / %s", layerIndex, groupId, mask, ReadMat4(box.coord)), optimize=false>;
}

if (bvh.uknOffset > 0) {
    FSeek(startof(bvh) + bvh.uknOffset);
    struct {
	    vec3p pos[bvh.normalCount];
    } Normals;
}

if (bvh.stringTableOffset > 0) {
    FSeek(startof(bvh) + bvh.stringTableOffset);
    struct {
        OffsetWString str(startof(bvh))[isMcol ? bvh.stringCount * 2 : 1];
    } StringTable <read=(exists(str[0].str) ? str[0].str : "<empty>")>;
}

FSeek(Header.mcolStringTableOffset);
struct {
    OffsetWString str(0)[bvh.stringCount * 2];
} MCOLStringTable <read=(exists(str[0].str) ? str[0].str : "<empty>")>;
